[
  {
    "objectID": "Module_5_RingWidth_only_model.html",
    "href": "Module_5_RingWidth_only_model.html",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "",
    "text": "This module introduces the workflow for the case where the only data informing the model is the ring-width dataset. This dataset includes diameter at time of coring, and one or more ring-width time series for each sampled tree.\nThis workflow involves:\n\nInferring growth using the state-space model;\nSampling models in STAN: A (very brief) overview\nVisualizing process and data uncertainty\nVisualizing chronology-like effects: year random effects\nUsing inferred growth to determine tree-level biomass\nComparing tree-level RW-only model to data-based biomass estimates\nScaling to stand & Calculating biomass increment from biomass.\n\n\n\nFirst we will infer tree growth using the state space model introduced in Module 4. We will use Stan to implement the model and estimate the model parameters. Stan which interfaces to R via a package called rstan.\nWe will also make use of several other packages to organize, summarize, and visualize both the data and model values.\n\n\n\n\nCode\nlibrary(rstan)\nlibrary(dplyr)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(gridExtra)\nlibrary(tidyr)\n\n\n\n\n\nThe data used to constrain the growth model includes the RW and Census data values. This is the same dataset used in Module 2.\nTo fit the model using rstan, the dataset needs to be a list of data objects.\n\n\nCode\n# load built dataset \ndat = readRDS('data/tree_data_HARVARD.RDS')\n\nclass(dat)\n\n\n[1] \"list\"\n\n\nCode\nnames(dat)\n\n\n [1] \"N_Xobs\"     \"N_years\"    \"N_X\"        \"N_X_C\"      \"N_Tr\"      \n [6] \"N_Dobs\"     \"N_C\"        \"N_taxa\"     \"Tr2X\"       \"Tr2X_C\"    \n[11] \"Tr2taxon\"   \"Tr2taxon_C\" \"X2C\"        \"X2Tr\"       \"X2Tr_C\"    \n[16] \"X2year\"     \"X2year_C\"   \"X2taxon\"    \"X2taxon_C\"  \"idx_C\"     \n[21] \"idx_Tr\"     \"Dobs2X\"     \"Xobs2X\"     \"Xobs2X_C\"   \"logDobs\"   \n[26] \"logTr\"      \"logXobs\"    \"Dobs\"       \"Tr\"         \"Xobs\"      \n[31] \"allTrees\"   \"years\"      \"taxa\"      \n\n\nCode\ntaxa = dat$taxa # the taxa abbreviations\nyears = dat$years # the years where we will estimate increments\n\n# STAN requires you to tell it the dimensions of the inputs and outputs, so we need to define these: \nN_years = dat$N_years # number of years\nN_Tr = dat$N_Tr # number of trees\nN_taxa = dat$N_taxa # number of taxa\nX2Tr = dat$X2Tr # vector of tree ids\nX2year = dat$X2year # vector of years for each tree\nTr = dat$Tr %&gt;% arrange(stat_id) # arrange the Tree data by ids, and save as Tr\ntaxon = Tr$taxon # vector of taxon ids\nplot = Tr$plot # vector of plot ids\nyears = dat$years # vector of calendar years\nyear_lo = min(years) # minimum year\nyear_hi = max(years) # maximum year\npdbh = exp(dat$logTr) #vector of diameters\n\n\nlist2env(dat, envir = globalenv())# load all the data objects into the environment\n\n\n&lt;environment: R_GlobalEnv&gt;\n\n\nCode\nN_C = dat$N_C # vector of Census ids\nX2C = dat$X2C # links the Census tree to the increment measurements\nX2year_C = dat$X2year_C\n\nallTrees = dat$allTrees %&gt;% arrange(stat_id)\ntaxon_C = allTrees$taxon\nplot_C = allTrees$plot\ndistance = allTrees$distance\n\n\n\n\n\n\n\n\nNote the use of X instead of R for increments\n\n\n\n\n\nIn the last module, the true increment for tree i at time t were refered to as \\(\\text{R}_{i, t}\\), but here we use \\(\\text{X}_{i, t}\\) as using R might be confusing as this is the name of our statistical software and R is not often used as a parameter name\n\n\n\nWe will also load a previous estimate of the DBH data uncertainty sig_d_obs, and add this to our dataset. This estimate is used as data in the RW-only of the model. We will estimate the DBH data uncertainty in the models that include census measurements.\n\n\nCode\nsig_d_obs = readRDS('data/sig_d_obs_RWC.RDS')\ndat$sig_d_obs = sig_d_obs\n\n\n\n\n\nThe stan model code is stored in the models/ folder. The RW only model is the growth_model_RW.stan. If you are working through this tutorial on R, you can view this file in your environment. We won’t dive too deep into how to write your own stan model, but note that this model includes several blocks:\n\ndata{}: inputs read in and used as “data” in the model\nparameters: defines the parameters that will be estimated in the model (we will draw samples from these in the model block)\ntransformed parameters: defines the parameters that are calculated from other parameters (we will draw samples from parameters and transform them into quantities we care about in this block)\nmodel: This is where the increment data model, diameter data model and liklihood function are defined\n\n\n\nCode\nwriteLines(readLines(\"models/growth_model_RW.stan\"))\n\n\n// RW ONLY MODEL \ndata {\n  int&lt;lower=0&gt; N_Tr;            // number of trees with rw measurements\n  int&lt;lower=0&gt; N_years;         // number of years of data \n  int&lt;lower=0&gt; N_X;             // number of increment values to estimate\n  int&lt;lower=0&gt; N_Xobs;          // total number of increments\n  int&lt;lower=0&gt; N_taxa;          // total number of taxa\n  int&lt;lower=0&gt; Tr2X[N_Tr];      // maps DBH measurements to estimated increment\n  int&lt;lower=0&gt; X2Tr[N_X];       // maps estimated increment values to tree ID\n  int&lt;lower=0&gt; X2year[N_X];     // maps estimated increment values to year ID\n  real logTr[N_Tr];             // log of DBH measurements\n  real logXobs[N_Xobs];         // log of increment measurements\n  real&lt;lower=0&gt; sig_d_obs;      // mean diameter measurement error\n  int&lt;lower=0&gt; idx_Tr[N_Tr, 3]; // indicates first and last value index for each tree ID\n  int&lt;lower=0&gt; Xobs2X[N_Xobs];  // maps increment measurements to estimated values\n\n  int&lt;lower=0&gt; X2taxon[N_X];\n  //int&lt;lower=0&gt; Tr2taxon[N_Tr];\n}\n\nparameters {\n  real beta0;\n  real beta[N_Tr];\n  real&lt;lower=0&gt; beta_sd;\n  real&lt;lower=0&gt; beta_t_sd;\n  // real&lt;lower=1e-6&gt; sig_x;\n  real&lt;lower=1e-6&gt; sig_x[N_taxa];\n  real&lt;lower=1e-6&gt; sig_x_obs;\n  real&lt;lower=-30, upper=80&gt; D0[N_Tr];\n  vector&lt;lower=1e-6&gt; [N_X] X;\n\n  matrix[N_years, N_taxa] beta_t;\n}\ntransformed parameters {\n    // process evolution\n  vector&lt;lower=-30&gt; [N_X] D;\n\n  for (tree in 1:N_Tr){\n    D[idx_Tr[tree,2]] = D0[tree] + 2.0 * X[idx_Tr[tree,2]] / 10.0;\n    for (val in (idx_Tr[tree,2]+1):(idx_Tr[tree,3])){\n      D[val] = D[val-1] + 2.0 * X[val] / 10.0;\n    }\n  }\n}\n\nmodel{\n\n  beta0     ~ normal(0, 1.0/0.00001);\n  sig_x_obs ~ uniform(1e-6, 2.0);\n  //sig_d_obs ~ uniform(1e-6, 1000);\n  \n  // sig_x     ~ uniform(1e-6, 1000);\n  beta_sd   ~ uniform(1e-6, 1000);\n  beta_t_sd ~ uniform(1e-6, 1000);\n    \n  for(tree in 1:N_Tr) {\n    D0[tree] ~ uniform(-30, 80);\n    beta[tree] ~ normal(beta0, beta_sd);\n  }\n  \n  // for(year in 1:N_years) {\n  //   beta_t[year] ~ normal(0, beta_t_sd);\n  // }\n\n    // temporal species effect prior \n  for(year in 1:N_years) {\n    beta_t[year,] ~ normal(0, beta_t_sd);\n  }\n\n  for (taxon in 1:N_taxa) {\n    sig_x[taxon] ~ uniform(1e-6, 1000);\n  }\n\n  \n  // increment likelihood\n  \n  // estimates \n  for (val in 1:N_X){\n    X[val] ~ lognormal(beta[X2Tr[val]] + beta_t[X2year[val], X2taxon[val]], sig_x[X2taxon[val]]);\n   }\n   \n  // RW estimates against RW increments\n  for (inc in 1:N_Xobs){\n   logXobs[inc] ~ normal(log(X[Xobs2X[inc]]), sig_x_obs);\n  }\n  \n  // diameter estimates against diameter measurements\n  for (tree in 1:N_Tr){\n    if (logTr[tree] == -999){\n    } else {\n      logTr[tree] ~ student_t(3, log(D[Tr2X[tree]]), sig_d_obs);\n    }\n  }\n}\n\n\n\n\n\n\n\n\nTo estimate growth using the growth model via Stan, we need to compile the model Stan code, and then sample from the parameter posterior distributions. The sampling function requires that we tell it the model we are using, the dataset we are using, the number of iterations, and the number of chains. The compute time for the sampling function can be quite long, depending on the model, data, and sampling algorithm settings (number of iterations and chains).\n\n\nCode\n# settings\niter = 500\nnchains = 1\n\ncompiled_RW = stan_model(file = paste0('models/growth_model_RW.stan'))\n\nfit_RW = sampling(compiled_RW, \n                  data = dat, \n                  iter = iter, \n                  chains = nchains,\n                  verbose=TRUE)\n\n\n\n\n\nWe will load the output from the fitted model (fitted model object and parameter posterior distributions).\n\n\n\n\nThe model output is a stanfit object. We can use this object to assess model fit, and to extract posterior distribution samples for the model parameters.\nThe default view for the object is a summary that shows summary statistics for the posterior samples for the model parameters. To access the summary table, you can use summary(fit_RW) There are arguments we can pass to the summary function to look at particular parameters, and specific the quantiles we want (among other things).\nBelow we look at a summary for the sig_x parameter, which characterizes the process uncertainty for each species, and the sig_x_obs parameter, which characterizes the increment data uncertainty for all of the data.\n\n\nCode\n#fit_RW\nlength(names(fit_RW)) # there are alot of parameters estimated in this model--each year for every tree has an estimated diameter (D[]), and an estimated increment (\"X\"), as well as an initial diameter estimate (D0[]).\n\n\n[1] 33819\n\n\nCode\n#summary(fit_RW)$summary # this will make a summary of the whole model fit, but is not loaded because there are so many parameters. Lets visualize a the taxa-level observation error and population-level observation errors for the increment uncertainty:\n\nsummary(fit_RW, pars = c('sig_x', 'sig_x_obs'), probs = c(0.1, 0.9))$summary\n\n\n                mean      se_mean          sd        10%       90%     n_eff\nsig_x[1]  0.20488190 0.0052774625 0.020517124 0.17592308 0.2305686  15.11411\nsig_x[2]  0.24361112 0.0004346820 0.003726972 0.23894971 0.2484215  73.51384\nsig_x[3]  0.53627250 0.0006165916 0.007418167 0.52692643 0.5451584 144.74316\nsig_x[4]  0.62271530 0.0023627334 0.022225488 0.59682482 0.6513141  88.48571\nsig_x[5]  0.43875025 0.0021508195 0.018479598 0.41554438 0.4614233  73.82052\nsig_x[6]  0.40137895 0.0078049201 0.050608128 0.33777250 0.4730428  42.04396\nsig_x[7]  0.36228570 0.0036568839 0.034923499 0.31907824 0.4030384  91.20385\nsig_x[8]  0.06669619 0.0094617907 0.023205397 0.04621721 0.1071442   6.01494\nsig_x[9]  0.17472524 0.0207195674 0.065658430 0.10860390 0.2671303  10.04199\nsig_x_obs 0.33355857 0.0001806953 0.001942860 0.33113140 0.3361441 115.60839\n               Rhat\nsig_x[1]  1.0348694\nsig_x[2]  1.0016063\nsig_x[3]  0.9976559\nsig_x[4]  0.9974586\nsig_x[5]  0.9974667\nsig_x[6]  1.0299605\nsig_x[7]  0.9963360\nsig_x[8]  1.2022020\nsig_x[9]  0.9996491\nsig_x_obs 1.0010834\n\n\n\n\n\nWhile not a complete list, we will look at 3 ways of evaluating the stan model fit itself: 1. Effective sample size 2. Rhat 3. Visualizing traceplots\n\n\nThe summary table also includes columns for effective sample size (n_eff) and Rhat. The effective sample size is a statistic used to estimate the number of posterior samples after accounting for autocorrelation. We want this number to be large. There is no definitive rule about the minimum n_eff needed to conclude that you have enough samples to make inference about model parameters, but the generally accepted minimum is 100 or 200 ESS for each parameter. In some cases the effective sample size can be larger than the total number of iterations.\nWe can use stan_ess to plot a histogram of the ratio of the effective sample size to the total number of iterations. The larger this value the better. Note than it can be larger than 1 because the ESS can be larger than the total number of iterations.\n\n\nCode\nstan_ess(fit_RW)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\nRhat is a statistic that estimates model convergence. It is one way to try to answer the question: has the sampler converged sufficiently so that we are getting samples from the posterior distribution? At convergence, Rhat is equal to 1. Perfect convergence is hard to achieve in practice, so generally we want Rhat smaller than 1.01 (but this is not always possible for all parameters for some complex models).\n\n\nCode\nstan_rhat(fit_RW)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\nTraceplots are useful to visualize if all the different chains are converging on a similar estimate for each value. If you think of an unknown parameter as a prime camping spot (or an old tree that you want to core), that you know is somewhere on a hillside, but not sure where. You might start wandering around randomly until you find the best camping spot. Your friends (who all started at different trailheads) represent different chains (random samplers) are also wandering around the same hillside until they find the best campsite. Hopefully, you all will converge (i.e. meet) at the same general spot on the hillside.\n\n&lt;img src=“DAGs/Convergence.png” width=“800”/&gt;\n\nHere we only show one chain, so it may not be as useful, but we can see that this estimate is varying around a mean value (and not slowly trending up/down over the number of samples).\n\n\nCode\ntraceplot(fit_RW, pars = c('sig_x_obs'))\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe will want to work with posterior samples for the model parameters, and we can get these by extracting them from the model output object into an easier to work with object. This object is a three dimensional array, which dimensions equal to the number of iterations BY the number of chains BY the number of parameters.\n\n\nCode\nclass(post_RW)\n\n\n[1] \"array\"\n\n\nCode\ndim(post_RW)\n\n\n[1]   250     1 33819\n\n\n\n\nTo assess model convergence we also typically look at trace plots of the series of posterior samples for parameters, and plots that summarize the posterior samples.\nHere we will consider the species specific process uncertainty parameter, sig_x. Each species has its own process uncertainty parameter. This means that there will be a set of posterior samples for sig_x for each species.\nFirst we summarize the posterior samples for sig_x by species.\n\n\nCode\n# this code is pulling out the model samples for each iteration and aligning the estimated process uncertainties for each taxa:\nvariables = names(post_RW[1,1,])\nallSX = grep('sig_x\\\\[',variables)\n\npost_sx = post_RW[,,allSX]\n\ndim(post_sx)\n\n\n[1] 250   9\n\n\nCode\ncolnames(post_sx) = taxa\npost_sx_melt = melt(post_sx)\ncolnames(post_sx_melt) = c('iteration', 'species_code', 'sigma_x')\npost_sx_melt$model = 'RW'\n\nsig_x_mean = post_sx_melt %&gt;% \n  group_by(species_code) %&gt;%\n  dplyr::summarize(sig_x_mean = mean(sigma_x))\nsig_x_mean = sig_x_mean[order(sig_x_mean$sig_x_mean),]\n\npost_sx_melt$species_code = factor(post_sx_melt$species_code, levels=sig_x_mean$species_code)\n\n# plot up the species level increment uncertainties\np = ggplot(data=post_sx_melt) +\n  # geom_boxplot(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  geom_violin(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  xlab('Species') +\n  ylab('sigma_x')\nprint(p)\n\n\n\n\n\n\n\n\n\nCode\np = ggplot(data=post_sx_melt) +\n  geom_histogram(aes(x=sigma_x, , y=after_stat(density), colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  xlab('sigma_x (increment data uncertainty)') +\n  facet_wrap(~species_code)\nprint(p)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nThen we look at the trace plots for the sig_x parameter for each species. Have all of these converged after 500 iterations?\n\n\nCode\np = ggplot(data=post_sx_melt) +\n  geom_line(aes(x=iteration, y=sigma_x)) +\n  geom_point(aes(x=iteration, y=sigma_x)) +\n  theme_bw(14) +\n  xlab('Iteration') +\n  ylab('sigma_x_obs') +\n  facet_wrap(~species_code, scales='free_y')\nprint(p)\n\n\n\n\n\n\n\n\n\nLet’s look a the same types of figures for sig_x_obs, the RW data uncertainty. In this model there is only one parameter for this process uncertainty, common among all species.\n\n\nCode\nvariables = names(post_RW[1,1,])\nallSXOBS = grep('sig_x_obs',variables)\n\npost_sxobs = post_RW[,,allSXOBS]\n\n# head(post_sx)\n# dim(post_sx)\n\npost_sxobs = data.frame(post_sxobs)\npost_sxobs$iteration = seq(1, nrow(post_sxobs))\ncolnames(post_sxobs) = c('sigma_x_obs', 'iteration')\npost_sxobs$model = 'RW'\n\np = ggplot(data=post_sxobs) +\n  # geom_boxplot(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  geom_violin(aes(x=model, y=sigma_x_obs, colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  #xlab('Species') +\n  ylab('sigma_x')\nprint(p)\n\n\n\n\n\n\n\n\n\nCode\np = ggplot(data=post_sxobs) +\n  geom_histogram(aes(x=sigma_x_obs, y=after_stat(density), colour=model, fill=model)) +\n  theme_bw(14) \nprint(p)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nCode\np = ggplot(data=post_sxobs) +\n  geom_line(aes(x=iteration, y=sigma_x_obs)) +\n  geom_point(aes(x=iteration, y=sigma_x_obs)) +\n  theme_bw(14) +\n  xlab('Iteration') +\n  ylab('sigma_x_obs') \nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we will also look at some summary figures for the beta_t parameter. For each species, there is a beta_t parameter for each year. This parameter is conceptually the same as a forest chronology; it is a time series that describes the common forest growth signal for a given species.\nWe could look at summary plots for the posterior samples for a given year for a given species, and do the same for all year BY species combinations. This would be (9 species) x (115 years) = 1035 trace plots, so we don’t look at all of them here.\nWe do want to visualize the beta_t chronology-like parameters as species-specific time series.\n\n\nCode\nallBTs = grep('beta_t\\\\[',variables)\npost_bt = post_RW[,,allBTs]\n\npost_bt_melt = melt(post_bt)\npost_bt_melt$model = 'RW'\n\nbt_pars_split = strsplit(as.vector(post_bt_melt$parameters), '\\\\[|\\\\,|\\\\]')\n\npost_bt_melt$species_code = taxa[sapply(bt_pars_split, function(x) as.numeric(x[[3]]))]\npost_bt_melt$year = years[sapply(bt_pars_split, function(x) as.numeric(x[[2]]))]\ncolnames(post_bt_melt) = c('iteration', 'parameter', 'beta_t', 'model', 'species_code', 'year')\n\nbeta_t_quant = post_bt_melt %&gt;% \n  group_by(model, species_code, year) %&gt;%\n  dplyr::summarize(beta_t_lo = quantile(beta_t, 0.025),\n                   beta_t_mid = quantile(beta_t, 0.5),\n                   beta_t_hi = quantile(beta_t, 0.975),\n                   beta_t_mean = mean(beta_t), \n                   .groups = 'keep')\n\np = ggplot(data=beta_t_quant) +\n  geom_hline(aes(yintercept=0), lty=2, lwd=1.2) +\n  geom_point(aes(x=year, y=beta_t_mid)) +\n  geom_linerange(aes(x=year, ymin=beta_t_lo, ymax=beta_t_hi)) +\n  xlab('year') +\n  ylab('beta_t') +\n  # xlim(c(year_lo, year_hi)) +\n  theme_bw(16) +\n  facet_grid(species_code~.)\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor the purpose of this workflow, we are most interested in the model inferred tree growth. For each tree, we have parameter estimates that describe increment and diameter growth through for each year.\nHere we visualize inferred and observed diameter data for one tree (Tree 1). Filled circles indicate the diameter measurement included in this model and hollow circles are census diameter measurements not included in the model.\n\n\nCode\nallDs = grep('D\\\\[',variables)\npost_d = post_RW[,,allDs]\n\ntree = 1\n\nin.RW = tree %in% X2Tr\n\nif (in.RW){\n  inds = which(X2Tr == tree)\n  yrinds = X2year[inds]\n  \n  dbh_iter = t(post_d[,inds])\n  dbh_iter = data.frame(dbh_iter)\n  dbh_iter = data.frame(year=years[yrinds], dbh_iter)\n  \n  dbh_mean = apply(dbh_iter[,2:ncol(dbh_iter)], 1, mean, na.rm=TRUE)\n  dbh_quant = t(apply(dbh_iter[,2:ncol(dbh_iter)], 1,\n                      function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  dbh_tree = data.frame(d_mean = dbh_mean,\n                        d_median = dbh_quant[,2],\n                        d_lo = dbh_quant[,1],\n                        d_hi = dbh_quant[,3],\n                        year = years[yrinds],\n                        model = 'RW')\n  \n}\n\n# determine which estimates correspond to this tree\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\n\nidx_d_obs_C = which(Dobs$stat_id == tree)\n\ndbh_obs_C = data.frame(d_obs = Dobs$dbh[idx_d_obs_C],\n                       year = years[Dobs$year[idx_d_obs_C]])\n\nstem_id = Dobs$ID[idx_d_obs_C][1]\n\nif (in.RW){\n  idx_d_obs = which(Tr$stat_id == tree)\n  \n  dbh_obs = data.frame(d_obs = Tr$dbh[idx_d_obs],\n                       year = years[Tr$year[idx_d_obs]])\n  \n} else {\n  dbh_obs = data.frame(d_obs = numeric(0),\n                       year = numeric(0))\n}\n\n# Create a text\ngrob = grobTree(textGrob(paste0('Tree ', tree, '; ID ', stem_id, '; Species ', taxon[tree] ), x=0.05,  y=0.9, hjust=0,\n                         gp=gpar(col=\"black\", fontsize=18)))\n\np1 = ggplot() +\n  geom_ribbon(data=dbh_tree, aes(x=year, ymin=d_lo, ymax=d_hi, fill=model), alpha=0.5) +\n  geom_line(data=dbh_tree, aes(x=year, y=d_median, colour=model)) +\n  geom_point(data=dbh_obs, aes(x=year, y=d_obs), size=2) +\n  geom_point(data=dbh_obs_C, aes(x=year, y=d_obs), size=2, shape=1) +\n  xlab('year') +\n  ylab('dbh (cm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  +\n  annotation_custom(grob)\n\nprint(p1)\n\n\n\n\n\n\n\n\n\nWe also visualize inferred and observed increment for this tree (Tree 1).\n\n\nCode\nallRWs = grep('X\\\\[',variables)\npost_rw = post_RW[,,allRWs]\n\nif (in.RW){\n  inds = which(X2Tr == tree)\n  yrinds = X2year[inds]\n  \n  rw_iter = t(post_rw[,inds])\n  rw_iter = data.frame(rw_iter)\n  rw_iter = data.frame(year=years[yrinds], rw_iter)\n  \n  rw_mean = apply(rw_iter[,2:ncol(rw_iter)], 1, mean, na.rm=TRUE)\n  rw_quant = t(apply(rw_iter[,2:ncol(rw_iter)], 1,\n                     function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  rw_tree = data.frame(x_mean = rw_mean,\n                       x_median = rw_quant[,2],\n                       x_lo = rw_quant[,1],\n                       x_hi = rw_quant[,3],\n                       year = years[yrinds],\n                       model = 'RW')\n}\n\n\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\nif (in.RW){\n  idx_rw_obs = which(Xobs$stat_id == tree)\n  \n  rw_obs = data.frame(x_obs = Xobs$incr[idx_rw_obs],\n                      year = years[Xobs$year[idx_rw_obs]])\n} else {\n  rw_obs = data.frame(x_obs = numeric(0),\n                      year = numeric(0))\n}\n\n# # Create a text\n# grob &lt;- grobTree(textGrob(paste0('Tree ', tree, '; Stem ID ', stem_id, '; Species ', taxon[tree] ), x=0.05,  y=0.9, hjust=0,\n#                           gp=gpar(col=\"black\", fontsize=22)))\n\np2 = ggplot() +\n  geom_ribbon(data=rw_tree, aes(x=year, ymin=x_lo, ymax=x_hi, fill=model), alpha=0.5) +\n  geom_line(data=rw_tree, aes(x=year, y=x_median, colour=model)) +\n  geom_point(data=rw_obs, aes(x=year, y=x_obs), size=2, alpha=0.4) +\n  xlab('year') +\n  ylab('rw (mm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  #+\n\ngrid.arrange(p1, p2, nrow = 2)\n\n\n\n\n\n\n\n\n\nLet’s visualize the inferred and observed growth for another tree as well.\n\n\nCode\ntree = 8\n\nin.RW = tree %in% X2Tr\n\nif (in.RW){\n  inds = which(X2Tr == tree)\n  yrinds = X2year[inds]\n  \n  dbh_iter = t(post_d[,inds])\n  dbh_iter = data.frame(dbh_iter)\n  dbh_iter = data.frame(year=years[yrinds], dbh_iter)\n  \n  dbh_mean = apply(dbh_iter[,2:ncol(dbh_iter)], 1, mean, na.rm=TRUE)\n  dbh_quant = t(apply(dbh_iter[,2:ncol(dbh_iter)], 1,\n                      function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  dbh_tree = data.frame(d_mean = dbh_mean,\n                        d_median = dbh_quant[,2],\n                        d_lo = dbh_quant[,1],\n                        d_hi = dbh_quant[,3],\n                        year = years[yrinds],\n                        model = 'RW')\n  \n}\n\n# determine which estimates correspond to this tree\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\n\nidx_d_obs_C = which(Dobs$stat_id == tree)\n\ndbh_obs_C = data.frame(d_obs = Dobs$dbh[idx_d_obs_C],\n                       year = years[Dobs$year[idx_d_obs_C]])\n\nstem_id = Dobs$ID[idx_d_obs_C][1]\n\nif (in.RW){\n  idx_d_obs = which(Tr$stat_id == tree)\n  \n  dbh_obs = data.frame(d_obs = Tr$dbh[idx_d_obs],\n                       year = years[Tr$year[idx_d_obs]])\n  \n} else {\n  dbh_obs = data.frame(d_obs = numeric(0),\n                       year = numeric(0))\n}\n\n# Create a text\ngrob = grobTree(textGrob(paste0('Tree ', tree, '; ID ', stem_id, '; Species ', taxon[tree] ), x=0.05,  y=0.9, hjust=0,\n                         gp=gpar(col=\"black\", fontsize=18)))\n\np1 = ggplot() +\n  geom_ribbon(data=dbh_tree, aes(x=year, ymin=d_lo, ymax=d_hi, fill=model), alpha=0.5) +\n  geom_line(data=dbh_tree, aes(x=year, y=d_median, colour=model)) +\n  geom_point(data=dbh_obs, aes(x=year, y=d_obs), size=2) +\n  geom_point(data=dbh_obs_C, aes(x=year, y=d_obs), size=2, shape=1) +\n  xlab('year') +\n  ylab('dbh (cm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  +\n  annotation_custom(grob)\n\n#print(p1)\n\nif (in.RW){\n  inds = which(X2Tr == tree)\n  yrinds = X2year[inds]\n  \n  rw_iter = t(post_rw[,inds])\n  rw_iter = data.frame(rw_iter)\n  rw_iter = data.frame(year=years[yrinds], rw_iter)\n  \n  rw_mean = apply(rw_iter[,2:ncol(rw_iter)], 1, mean, na.rm=TRUE)\n  rw_quant = t(apply(rw_iter[,2:ncol(rw_iter)], 1,\n                     function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  rw_tree = data.frame(x_mean = rw_mean,\n                       x_median = rw_quant[,2],\n                       x_lo = rw_quant[,1],\n                       x_hi = rw_quant[,3],\n                       year = years[yrinds],\n                       model = 'RW')\n}\n\n\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\nif (in.RW){\n  idx_rw_obs = which(Xobs$stat_id == tree)\n  \n  rw_obs = data.frame(x_obs = Xobs$incr[idx_rw_obs],\n                      year = years[Xobs$year[idx_rw_obs]])\n} else {\n  rw_obs = data.frame(x_obs = numeric(0),\n                      year = numeric(0))\n}\n\np2 = ggplot() +\n  geom_ribbon(data=rw_tree, aes(x=year, ymin=x_lo, ymax=x_hi, fill=model), alpha=0.5) +\n  geom_line(data=rw_tree, aes(x=year, y=x_median, colour=model)) +\n  geom_point(data=rw_obs, aes(x=year, y=x_obs), size=2, alpha=0.4) +\n  xlab('year') +\n  ylab('rw (mm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  #+\n\ngrid.arrange(p1, p2, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n\n\nWe have looked at diagnostics of the model sampling step, but it is a good idea to do some additional model validation. This typically involved comparing model and data values. Here we will visualize model inferred versus observed diamater and increment.\nThe modelled and observed diameter and increment values have already been organized into data frames. We will load them in order to visualize the information.\nFirst we will look at the model versus data diameter scatter plot.\n\n\nCode\n# comparing estimates of diameter increment to observation\ndbh_validate = readRDS('output/DBH_VALIDATE_HARVARD.RDS')\ndbh_validate = subset(dbh_validate, model == 'RW')\n\np = ggplot(data=dbh_validate) +\n  geom_abline(intercept=0, slope=1, lty=2, colour='red') +\n  geom_linerange(aes(x=d_obs, ymin=d_model_lo, ymax=d_model_hi, colour=model), alpha=0.3) +\n  geom_point(aes(x=d_obs, y=d_model_median, colour=model), size=2, alpha=0.3) +\n  geom_line(stat='smooth', method='lm', formula = y ~ x, aes(x=d_obs, y=d_model_median), colour = 'blue', alpha=0.5, fullrange=TRUE) +\n  xlab('dbh obs (cm)') +\n  ylab('dbh model (cm)') +\n  theme_bw(16) +\n  coord_fixed() \nprint(p)\n\n\n\n\n\n\n\n\n\nNow we visualize the model versus data diameter using a scatter plot. The Blue line is the best-fit line through the median predictions vs. observations. Do you think this model is under or over estimating increment data?\n\n\nCode\nrw_validate = readRDS('output/RW_VALIDATE_HARVARD.RDS')\nrw_validate = subset(rw_validate, model == 'RW')\n\nq = ggplot(data=rw_validate) +\n  geom_abline(intercept=0, slope=1, lty=2, colour='red') +\n  geom_smooth(method='lm', aes(x=rw_obs, y=rw_model_median), fullrange=TRUE) +\n  geom_linerange(aes(x=rw_obs, ymin=rw_model_lo, ymax=rw_model_hi, colour=model), alpha=0.3) +\n  geom_point(aes(x=rw_obs, y=rw_model_median, colour=model), size=2, alpha=0.3) +\n  xlab('rw obs (mm)') +\n  ylab('rw model (mm)') +\n  theme_bw(16) \nprint(q)\n\n\n`geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#inferring-growth-using-the-state-space-model",
    "href": "Module_5_RingWidth_only_model.html#inferring-growth-using-the-state-space-model",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "",
    "text": "First we will infer tree growth using the state space model introduced in Module 4. We will use Stan to implement the model and estimate the model parameters. Stan which interfaces to R via a package called rstan.\nWe will also make use of several other packages to organize, summarize, and visualize both the data and model values.\n\n\n\n\nCode\nlibrary(rstan)\nlibrary(dplyr)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(gridExtra)\nlibrary(tidyr)\n\n\n\n\n\nThe data used to constrain the growth model includes the RW and Census data values. This is the same dataset used in Module 2.\nTo fit the model using rstan, the dataset needs to be a list of data objects.\n\n\nCode\n# load built dataset \ndat = readRDS('data/tree_data_HARVARD.RDS')\n\nclass(dat)\n\n\n[1] \"list\"\n\n\nCode\nnames(dat)\n\n\n [1] \"N_Xobs\"     \"N_years\"    \"N_X\"        \"N_X_C\"      \"N_Tr\"      \n [6] \"N_Dobs\"     \"N_C\"        \"N_taxa\"     \"Tr2X\"       \"Tr2X_C\"    \n[11] \"Tr2taxon\"   \"Tr2taxon_C\" \"X2C\"        \"X2Tr\"       \"X2Tr_C\"    \n[16] \"X2year\"     \"X2year_C\"   \"X2taxon\"    \"X2taxon_C\"  \"idx_C\"     \n[21] \"idx_Tr\"     \"Dobs2X\"     \"Xobs2X\"     \"Xobs2X_C\"   \"logDobs\"   \n[26] \"logTr\"      \"logXobs\"    \"Dobs\"       \"Tr\"         \"Xobs\"      \n[31] \"allTrees\"   \"years\"      \"taxa\"      \n\n\nCode\ntaxa = dat$taxa # the taxa abbreviations\nyears = dat$years # the years where we will estimate increments\n\n# STAN requires you to tell it the dimensions of the inputs and outputs, so we need to define these: \nN_years = dat$N_years # number of years\nN_Tr = dat$N_Tr # number of trees\nN_taxa = dat$N_taxa # number of taxa\nX2Tr = dat$X2Tr # vector of tree ids\nX2year = dat$X2year # vector of years for each tree\nTr = dat$Tr %&gt;% arrange(stat_id) # arrange the Tree data by ids, and save as Tr\ntaxon = Tr$taxon # vector of taxon ids\nplot = Tr$plot # vector of plot ids\nyears = dat$years # vector of calendar years\nyear_lo = min(years) # minimum year\nyear_hi = max(years) # maximum year\npdbh = exp(dat$logTr) #vector of diameters\n\n\nlist2env(dat, envir = globalenv())# load all the data objects into the environment\n\n\n&lt;environment: R_GlobalEnv&gt;\n\n\nCode\nN_C = dat$N_C # vector of Census ids\nX2C = dat$X2C # links the Census tree to the increment measurements\nX2year_C = dat$X2year_C\n\nallTrees = dat$allTrees %&gt;% arrange(stat_id)\ntaxon_C = allTrees$taxon\nplot_C = allTrees$plot\ndistance = allTrees$distance\n\n\n\n\n\n\n\n\nNote the use of X instead of R for increments\n\n\n\n\n\nIn the last module, the true increment for tree i at time t were refered to as \\(\\text{R}_{i, t}\\), but here we use \\(\\text{X}_{i, t}\\) as using R might be confusing as this is the name of our statistical software and R is not often used as a parameter name\n\n\n\nWe will also load a previous estimate of the DBH data uncertainty sig_d_obs, and add this to our dataset. This estimate is used as data in the RW-only of the model. We will estimate the DBH data uncertainty in the models that include census measurements.\n\n\nCode\nsig_d_obs = readRDS('data/sig_d_obs_RWC.RDS')\ndat$sig_d_obs = sig_d_obs\n\n\n\n\n\nThe stan model code is stored in the models/ folder. The RW only model is the growth_model_RW.stan. If you are working through this tutorial on R, you can view this file in your environment. We won’t dive too deep into how to write your own stan model, but note that this model includes several blocks:\n\ndata{}: inputs read in and used as “data” in the model\nparameters: defines the parameters that will be estimated in the model (we will draw samples from these in the model block)\ntransformed parameters: defines the parameters that are calculated from other parameters (we will draw samples from parameters and transform them into quantities we care about in this block)\nmodel: This is where the increment data model, diameter data model and liklihood function are defined\n\n\n\nCode\nwriteLines(readLines(\"models/growth_model_RW.stan\"))\n\n\n// RW ONLY MODEL \ndata {\n  int&lt;lower=0&gt; N_Tr;            // number of trees with rw measurements\n  int&lt;lower=0&gt; N_years;         // number of years of data \n  int&lt;lower=0&gt; N_X;             // number of increment values to estimate\n  int&lt;lower=0&gt; N_Xobs;          // total number of increments\n  int&lt;lower=0&gt; N_taxa;          // total number of taxa\n  int&lt;lower=0&gt; Tr2X[N_Tr];      // maps DBH measurements to estimated increment\n  int&lt;lower=0&gt; X2Tr[N_X];       // maps estimated increment values to tree ID\n  int&lt;lower=0&gt; X2year[N_X];     // maps estimated increment values to year ID\n  real logTr[N_Tr];             // log of DBH measurements\n  real logXobs[N_Xobs];         // log of increment measurements\n  real&lt;lower=0&gt; sig_d_obs;      // mean diameter measurement error\n  int&lt;lower=0&gt; idx_Tr[N_Tr, 3]; // indicates first and last value index for each tree ID\n  int&lt;lower=0&gt; Xobs2X[N_Xobs];  // maps increment measurements to estimated values\n\n  int&lt;lower=0&gt; X2taxon[N_X];\n  //int&lt;lower=0&gt; Tr2taxon[N_Tr];\n}\n\nparameters {\n  real beta0;\n  real beta[N_Tr];\n  real&lt;lower=0&gt; beta_sd;\n  real&lt;lower=0&gt; beta_t_sd;\n  // real&lt;lower=1e-6&gt; sig_x;\n  real&lt;lower=1e-6&gt; sig_x[N_taxa];\n  real&lt;lower=1e-6&gt; sig_x_obs;\n  real&lt;lower=-30, upper=80&gt; D0[N_Tr];\n  vector&lt;lower=1e-6&gt; [N_X] X;\n\n  matrix[N_years, N_taxa] beta_t;\n}\ntransformed parameters {\n    // process evolution\n  vector&lt;lower=-30&gt; [N_X] D;\n\n  for (tree in 1:N_Tr){\n    D[idx_Tr[tree,2]] = D0[tree] + 2.0 * X[idx_Tr[tree,2]] / 10.0;\n    for (val in (idx_Tr[tree,2]+1):(idx_Tr[tree,3])){\n      D[val] = D[val-1] + 2.0 * X[val] / 10.0;\n    }\n  }\n}\n\nmodel{\n\n  beta0     ~ normal(0, 1.0/0.00001);\n  sig_x_obs ~ uniform(1e-6, 2.0);\n  //sig_d_obs ~ uniform(1e-6, 1000);\n  \n  // sig_x     ~ uniform(1e-6, 1000);\n  beta_sd   ~ uniform(1e-6, 1000);\n  beta_t_sd ~ uniform(1e-6, 1000);\n    \n  for(tree in 1:N_Tr) {\n    D0[tree] ~ uniform(-30, 80);\n    beta[tree] ~ normal(beta0, beta_sd);\n  }\n  \n  // for(year in 1:N_years) {\n  //   beta_t[year] ~ normal(0, beta_t_sd);\n  // }\n\n    // temporal species effect prior \n  for(year in 1:N_years) {\n    beta_t[year,] ~ normal(0, beta_t_sd);\n  }\n\n  for (taxon in 1:N_taxa) {\n    sig_x[taxon] ~ uniform(1e-6, 1000);\n  }\n\n  \n  // increment likelihood\n  \n  // estimates \n  for (val in 1:N_X){\n    X[val] ~ lognormal(beta[X2Tr[val]] + beta_t[X2year[val], X2taxon[val]], sig_x[X2taxon[val]]);\n   }\n   \n  // RW estimates against RW increments\n  for (inc in 1:N_Xobs){\n   logXobs[inc] ~ normal(log(X[Xobs2X[inc]]), sig_x_obs);\n  }\n  \n  // diameter estimates against diameter measurements\n  for (tree in 1:N_Tr){\n    if (logTr[tree] == -999){\n    } else {\n      logTr[tree] ~ student_t(3, log(D[Tr2X[tree]]), sig_d_obs);\n    }\n  }\n}",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#sampling-models-in-stan-a-very-brief-overview",
    "href": "Module_5_RingWidth_only_model.html#sampling-models-in-stan-a-very-brief-overview",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "",
    "text": "To estimate growth using the growth model via Stan, we need to compile the model Stan code, and then sample from the parameter posterior distributions. The sampling function requires that we tell it the model we are using, the dataset we are using, the number of iterations, and the number of chains. The compute time for the sampling function can be quite long, depending on the model, data, and sampling algorithm settings (number of iterations and chains).\n\n\nCode\n# settings\niter = 500\nnchains = 1\n\ncompiled_RW = stan_model(file = paste0('models/growth_model_RW.stan'))\n\nfit_RW = sampling(compiled_RW, \n                  data = dat, \n                  iter = iter, \n                  chains = nchains,\n                  verbose=TRUE)\n\n\n\n\n\nWe will load the output from the fitted model (fitted model object and parameter posterior distributions).",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#summarizing-model-fitvisualizing-process-and-data-uncertainty",
    "href": "Module_5_RingWidth_only_model.html#summarizing-model-fitvisualizing-process-and-data-uncertainty",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "",
    "text": "The model output is a stanfit object. We can use this object to assess model fit, and to extract posterior distribution samples for the model parameters.\nThe default view for the object is a summary that shows summary statistics for the posterior samples for the model parameters. To access the summary table, you can use summary(fit_RW) There are arguments we can pass to the summary function to look at particular parameters, and specific the quantiles we want (among other things).\nBelow we look at a summary for the sig_x parameter, which characterizes the process uncertainty for each species, and the sig_x_obs parameter, which characterizes the increment data uncertainty for all of the data.\n\n\nCode\n#fit_RW\nlength(names(fit_RW)) # there are alot of parameters estimated in this model--each year for every tree has an estimated diameter (D[]), and an estimated increment (\"X\"), as well as an initial diameter estimate (D0[]).\n\n\n[1] 33819\n\n\nCode\n#summary(fit_RW)$summary # this will make a summary of the whole model fit, but is not loaded because there are so many parameters. Lets visualize a the taxa-level observation error and population-level observation errors for the increment uncertainty:\n\nsummary(fit_RW, pars = c('sig_x', 'sig_x_obs'), probs = c(0.1, 0.9))$summary\n\n\n                mean      se_mean          sd        10%       90%     n_eff\nsig_x[1]  0.20488190 0.0052774625 0.020517124 0.17592308 0.2305686  15.11411\nsig_x[2]  0.24361112 0.0004346820 0.003726972 0.23894971 0.2484215  73.51384\nsig_x[3]  0.53627250 0.0006165916 0.007418167 0.52692643 0.5451584 144.74316\nsig_x[4]  0.62271530 0.0023627334 0.022225488 0.59682482 0.6513141  88.48571\nsig_x[5]  0.43875025 0.0021508195 0.018479598 0.41554438 0.4614233  73.82052\nsig_x[6]  0.40137895 0.0078049201 0.050608128 0.33777250 0.4730428  42.04396\nsig_x[7]  0.36228570 0.0036568839 0.034923499 0.31907824 0.4030384  91.20385\nsig_x[8]  0.06669619 0.0094617907 0.023205397 0.04621721 0.1071442   6.01494\nsig_x[9]  0.17472524 0.0207195674 0.065658430 0.10860390 0.2671303  10.04199\nsig_x_obs 0.33355857 0.0001806953 0.001942860 0.33113140 0.3361441 115.60839\n               Rhat\nsig_x[1]  1.0348694\nsig_x[2]  1.0016063\nsig_x[3]  0.9976559\nsig_x[4]  0.9974586\nsig_x[5]  0.9974667\nsig_x[6]  1.0299605\nsig_x[7]  0.9963360\nsig_x[8]  1.2022020\nsig_x[9]  0.9996491\nsig_x_obs 1.0010834",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#evaluating-model-convergencehow-do-we-know-we-have-enough-iterations-sampled",
    "href": "Module_5_RingWidth_only_model.html#evaluating-model-convergencehow-do-we-know-we-have-enough-iterations-sampled",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "",
    "text": "While not a complete list, we will look at 3 ways of evaluating the stan model fit itself: 1. Effective sample size 2. Rhat 3. Visualizing traceplots\n\n\nThe summary table also includes columns for effective sample size (n_eff) and Rhat. The effective sample size is a statistic used to estimate the number of posterior samples after accounting for autocorrelation. We want this number to be large. There is no definitive rule about the minimum n_eff needed to conclude that you have enough samples to make inference about model parameters, but the generally accepted minimum is 100 or 200 ESS for each parameter. In some cases the effective sample size can be larger than the total number of iterations.\nWe can use stan_ess to plot a histogram of the ratio of the effective sample size to the total number of iterations. The larger this value the better. Note than it can be larger than 1 because the ESS can be larger than the total number of iterations.\n\n\nCode\nstan_ess(fit_RW)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\nRhat is a statistic that estimates model convergence. It is one way to try to answer the question: has the sampler converged sufficiently so that we are getting samples from the posterior distribution? At convergence, Rhat is equal to 1. Perfect convergence is hard to achieve in practice, so generally we want Rhat smaller than 1.01 (but this is not always possible for all parameters for some complex models).\n\n\nCode\nstan_rhat(fit_RW)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\nTraceplots are useful to visualize if all the different chains are converging on a similar estimate for each value. If you think of an unknown parameter as a prime camping spot (or an old tree that you want to core), that you know is somewhere on a hillside, but not sure where. You might start wandering around randomly until you find the best camping spot. Your friends (who all started at different trailheads) represent different chains (random samplers) are also wandering around the same hillside until they find the best campsite. Hopefully, you all will converge (i.e. meet) at the same general spot on the hillside.\n\n&lt;img src=“DAGs/Convergence.png” width=“800”/&gt;\n\nHere we only show one chain, so it may not be as useful, but we can see that this estimate is varying around a mean value (and not slowly trending up/down over the number of samples).\n\n\nCode\ntraceplot(fit_RW, pars = c('sig_x_obs'))",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#visualizing-process-and-data-uncertainty",
    "href": "Module_5_RingWidth_only_model.html#visualizing-process-and-data-uncertainty",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "",
    "text": "We will want to work with posterior samples for the model parameters, and we can get these by extracting them from the model output object into an easier to work with object. This object is a three dimensional array, which dimensions equal to the number of iterations BY the number of chains BY the number of parameters.\n\n\nCode\nclass(post_RW)\n\n\n[1] \"array\"\n\n\nCode\ndim(post_RW)\n\n\n[1]   250     1 33819\n\n\n\n\nTo assess model convergence we also typically look at trace plots of the series of posterior samples for parameters, and plots that summarize the posterior samples.\nHere we will consider the species specific process uncertainty parameter, sig_x. Each species has its own process uncertainty parameter. This means that there will be a set of posterior samples for sig_x for each species.\nFirst we summarize the posterior samples for sig_x by species.\n\n\nCode\n# this code is pulling out the model samples for each iteration and aligning the estimated process uncertainties for each taxa:\nvariables = names(post_RW[1,1,])\nallSX = grep('sig_x\\\\[',variables)\n\npost_sx = post_RW[,,allSX]\n\ndim(post_sx)\n\n\n[1] 250   9\n\n\nCode\ncolnames(post_sx) = taxa\npost_sx_melt = melt(post_sx)\ncolnames(post_sx_melt) = c('iteration', 'species_code', 'sigma_x')\npost_sx_melt$model = 'RW'\n\nsig_x_mean = post_sx_melt %&gt;% \n  group_by(species_code) %&gt;%\n  dplyr::summarize(sig_x_mean = mean(sigma_x))\nsig_x_mean = sig_x_mean[order(sig_x_mean$sig_x_mean),]\n\npost_sx_melt$species_code = factor(post_sx_melt$species_code, levels=sig_x_mean$species_code)\n\n# plot up the species level increment uncertainties\np = ggplot(data=post_sx_melt) +\n  # geom_boxplot(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  geom_violin(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  xlab('Species') +\n  ylab('sigma_x')\nprint(p)\n\n\n\n\n\n\n\n\n\nCode\np = ggplot(data=post_sx_melt) +\n  geom_histogram(aes(x=sigma_x, , y=after_stat(density), colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  xlab('sigma_x (increment data uncertainty)') +\n  facet_wrap(~species_code)\nprint(p)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nThen we look at the trace plots for the sig_x parameter for each species. Have all of these converged after 500 iterations?\n\n\nCode\np = ggplot(data=post_sx_melt) +\n  geom_line(aes(x=iteration, y=sigma_x)) +\n  geom_point(aes(x=iteration, y=sigma_x)) +\n  theme_bw(14) +\n  xlab('Iteration') +\n  ylab('sigma_x_obs') +\n  facet_wrap(~species_code, scales='free_y')\nprint(p)\n\n\n\n\n\n\n\n\n\nLet’s look a the same types of figures for sig_x_obs, the RW data uncertainty. In this model there is only one parameter for this process uncertainty, common among all species.\n\n\nCode\nvariables = names(post_RW[1,1,])\nallSXOBS = grep('sig_x_obs',variables)\n\npost_sxobs = post_RW[,,allSXOBS]\n\n# head(post_sx)\n# dim(post_sx)\n\npost_sxobs = data.frame(post_sxobs)\npost_sxobs$iteration = seq(1, nrow(post_sxobs))\ncolnames(post_sxobs) = c('sigma_x_obs', 'iteration')\npost_sxobs$model = 'RW'\n\np = ggplot(data=post_sxobs) +\n  # geom_boxplot(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  geom_violin(aes(x=model, y=sigma_x_obs, colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  #xlab('Species') +\n  ylab('sigma_x')\nprint(p)\n\n\n\n\n\n\n\n\n\nCode\np = ggplot(data=post_sxobs) +\n  geom_histogram(aes(x=sigma_x_obs, y=after_stat(density), colour=model, fill=model)) +\n  theme_bw(14) \nprint(p)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nCode\np = ggplot(data=post_sxobs) +\n  geom_line(aes(x=iteration, y=sigma_x_obs)) +\n  geom_point(aes(x=iteration, y=sigma_x_obs)) +\n  theme_bw(14) +\n  xlab('Iteration') +\n  ylab('sigma_x_obs') \nprint(p)",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#visualizing-chronology-like-effects-year-random-effects",
    "href": "Module_5_RingWidth_only_model.html#visualizing-chronology-like-effects-year-random-effects",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "",
    "text": "Here we will also look at some summary figures for the beta_t parameter. For each species, there is a beta_t parameter for each year. This parameter is conceptually the same as a forest chronology; it is a time series that describes the common forest growth signal for a given species.\nWe could look at summary plots for the posterior samples for a given year for a given species, and do the same for all year BY species combinations. This would be (9 species) x (115 years) = 1035 trace plots, so we don’t look at all of them here.\nWe do want to visualize the beta_t chronology-like parameters as species-specific time series.\n\n\nCode\nallBTs = grep('beta_t\\\\[',variables)\npost_bt = post_RW[,,allBTs]\n\npost_bt_melt = melt(post_bt)\npost_bt_melt$model = 'RW'\n\nbt_pars_split = strsplit(as.vector(post_bt_melt$parameters), '\\\\[|\\\\,|\\\\]')\n\npost_bt_melt$species_code = taxa[sapply(bt_pars_split, function(x) as.numeric(x[[3]]))]\npost_bt_melt$year = years[sapply(bt_pars_split, function(x) as.numeric(x[[2]]))]\ncolnames(post_bt_melt) = c('iteration', 'parameter', 'beta_t', 'model', 'species_code', 'year')\n\nbeta_t_quant = post_bt_melt %&gt;% \n  group_by(model, species_code, year) %&gt;%\n  dplyr::summarize(beta_t_lo = quantile(beta_t, 0.025),\n                   beta_t_mid = quantile(beta_t, 0.5),\n                   beta_t_hi = quantile(beta_t, 0.975),\n                   beta_t_mean = mean(beta_t), \n                   .groups = 'keep')\n\np = ggplot(data=beta_t_quant) +\n  geom_hline(aes(yintercept=0), lty=2, lwd=1.2) +\n  geom_point(aes(x=year, y=beta_t_mid)) +\n  geom_linerange(aes(x=year, ymin=beta_t_lo, ymax=beta_t_hi)) +\n  xlab('year') +\n  ylab('beta_t') +\n  # xlim(c(year_lo, year_hi)) +\n  theme_bw(16) +\n  facet_grid(species_code~.)\nprint(p)",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#using-inferred-growth-to-determine-tree-level-biomass",
    "href": "Module_5_RingWidth_only_model.html#using-inferred-growth-to-determine-tree-level-biomass",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "",
    "text": "For the purpose of this workflow, we are most interested in the model inferred tree growth. For each tree, we have parameter estimates that describe increment and diameter growth through for each year.\nHere we visualize inferred and observed diameter data for one tree (Tree 1). Filled circles indicate the diameter measurement included in this model and hollow circles are census diameter measurements not included in the model.\n\n\nCode\nallDs = grep('D\\\\[',variables)\npost_d = post_RW[,,allDs]\n\ntree = 1\n\nin.RW = tree %in% X2Tr\n\nif (in.RW){\n  inds = which(X2Tr == tree)\n  yrinds = X2year[inds]\n  \n  dbh_iter = t(post_d[,inds])\n  dbh_iter = data.frame(dbh_iter)\n  dbh_iter = data.frame(year=years[yrinds], dbh_iter)\n  \n  dbh_mean = apply(dbh_iter[,2:ncol(dbh_iter)], 1, mean, na.rm=TRUE)\n  dbh_quant = t(apply(dbh_iter[,2:ncol(dbh_iter)], 1,\n                      function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  dbh_tree = data.frame(d_mean = dbh_mean,\n                        d_median = dbh_quant[,2],\n                        d_lo = dbh_quant[,1],\n                        d_hi = dbh_quant[,3],\n                        year = years[yrinds],\n                        model = 'RW')\n  \n}\n\n# determine which estimates correspond to this tree\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\n\nidx_d_obs_C = which(Dobs$stat_id == tree)\n\ndbh_obs_C = data.frame(d_obs = Dobs$dbh[idx_d_obs_C],\n                       year = years[Dobs$year[idx_d_obs_C]])\n\nstem_id = Dobs$ID[idx_d_obs_C][1]\n\nif (in.RW){\n  idx_d_obs = which(Tr$stat_id == tree)\n  \n  dbh_obs = data.frame(d_obs = Tr$dbh[idx_d_obs],\n                       year = years[Tr$year[idx_d_obs]])\n  \n} else {\n  dbh_obs = data.frame(d_obs = numeric(0),\n                       year = numeric(0))\n}\n\n# Create a text\ngrob = grobTree(textGrob(paste0('Tree ', tree, '; ID ', stem_id, '; Species ', taxon[tree] ), x=0.05,  y=0.9, hjust=0,\n                         gp=gpar(col=\"black\", fontsize=18)))\n\np1 = ggplot() +\n  geom_ribbon(data=dbh_tree, aes(x=year, ymin=d_lo, ymax=d_hi, fill=model), alpha=0.5) +\n  geom_line(data=dbh_tree, aes(x=year, y=d_median, colour=model)) +\n  geom_point(data=dbh_obs, aes(x=year, y=d_obs), size=2) +\n  geom_point(data=dbh_obs_C, aes(x=year, y=d_obs), size=2, shape=1) +\n  xlab('year') +\n  ylab('dbh (cm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  +\n  annotation_custom(grob)\n\nprint(p1)\n\n\n\n\n\n\n\n\n\nWe also visualize inferred and observed increment for this tree (Tree 1).\n\n\nCode\nallRWs = grep('X\\\\[',variables)\npost_rw = post_RW[,,allRWs]\n\nif (in.RW){\n  inds = which(X2Tr == tree)\n  yrinds = X2year[inds]\n  \n  rw_iter = t(post_rw[,inds])\n  rw_iter = data.frame(rw_iter)\n  rw_iter = data.frame(year=years[yrinds], rw_iter)\n  \n  rw_mean = apply(rw_iter[,2:ncol(rw_iter)], 1, mean, na.rm=TRUE)\n  rw_quant = t(apply(rw_iter[,2:ncol(rw_iter)], 1,\n                     function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  rw_tree = data.frame(x_mean = rw_mean,\n                       x_median = rw_quant[,2],\n                       x_lo = rw_quant[,1],\n                       x_hi = rw_quant[,3],\n                       year = years[yrinds],\n                       model = 'RW')\n}\n\n\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\nif (in.RW){\n  idx_rw_obs = which(Xobs$stat_id == tree)\n  \n  rw_obs = data.frame(x_obs = Xobs$incr[idx_rw_obs],\n                      year = years[Xobs$year[idx_rw_obs]])\n} else {\n  rw_obs = data.frame(x_obs = numeric(0),\n                      year = numeric(0))\n}\n\n# # Create a text\n# grob &lt;- grobTree(textGrob(paste0('Tree ', tree, '; Stem ID ', stem_id, '; Species ', taxon[tree] ), x=0.05,  y=0.9, hjust=0,\n#                           gp=gpar(col=\"black\", fontsize=22)))\n\np2 = ggplot() +\n  geom_ribbon(data=rw_tree, aes(x=year, ymin=x_lo, ymax=x_hi, fill=model), alpha=0.5) +\n  geom_line(data=rw_tree, aes(x=year, y=x_median, colour=model)) +\n  geom_point(data=rw_obs, aes(x=year, y=x_obs), size=2, alpha=0.4) +\n  xlab('year') +\n  ylab('rw (mm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  #+\n\ngrid.arrange(p1, p2, nrow = 2)\n\n\n\n\n\n\n\n\n\nLet’s visualize the inferred and observed growth for another tree as well.\n\n\nCode\ntree = 8\n\nin.RW = tree %in% X2Tr\n\nif (in.RW){\n  inds = which(X2Tr == tree)\n  yrinds = X2year[inds]\n  \n  dbh_iter = t(post_d[,inds])\n  dbh_iter = data.frame(dbh_iter)\n  dbh_iter = data.frame(year=years[yrinds], dbh_iter)\n  \n  dbh_mean = apply(dbh_iter[,2:ncol(dbh_iter)], 1, mean, na.rm=TRUE)\n  dbh_quant = t(apply(dbh_iter[,2:ncol(dbh_iter)], 1,\n                      function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  dbh_tree = data.frame(d_mean = dbh_mean,\n                        d_median = dbh_quant[,2],\n                        d_lo = dbh_quant[,1],\n                        d_hi = dbh_quant[,3],\n                        year = years[yrinds],\n                        model = 'RW')\n  \n}\n\n# determine which estimates correspond to this tree\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\n\nidx_d_obs_C = which(Dobs$stat_id == tree)\n\ndbh_obs_C = data.frame(d_obs = Dobs$dbh[idx_d_obs_C],\n                       year = years[Dobs$year[idx_d_obs_C]])\n\nstem_id = Dobs$ID[idx_d_obs_C][1]\n\nif (in.RW){\n  idx_d_obs = which(Tr$stat_id == tree)\n  \n  dbh_obs = data.frame(d_obs = Tr$dbh[idx_d_obs],\n                       year = years[Tr$year[idx_d_obs]])\n  \n} else {\n  dbh_obs = data.frame(d_obs = numeric(0),\n                       year = numeric(0))\n}\n\n# Create a text\ngrob = grobTree(textGrob(paste0('Tree ', tree, '; ID ', stem_id, '; Species ', taxon[tree] ), x=0.05,  y=0.9, hjust=0,\n                         gp=gpar(col=\"black\", fontsize=18)))\n\np1 = ggplot() +\n  geom_ribbon(data=dbh_tree, aes(x=year, ymin=d_lo, ymax=d_hi, fill=model), alpha=0.5) +\n  geom_line(data=dbh_tree, aes(x=year, y=d_median, colour=model)) +\n  geom_point(data=dbh_obs, aes(x=year, y=d_obs), size=2) +\n  geom_point(data=dbh_obs_C, aes(x=year, y=d_obs), size=2, shape=1) +\n  xlab('year') +\n  ylab('dbh (cm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  +\n  annotation_custom(grob)\n\n#print(p1)\n\nif (in.RW){\n  inds = which(X2Tr == tree)\n  yrinds = X2year[inds]\n  \n  rw_iter = t(post_rw[,inds])\n  rw_iter = data.frame(rw_iter)\n  rw_iter = data.frame(year=years[yrinds], rw_iter)\n  \n  rw_mean = apply(rw_iter[,2:ncol(rw_iter)], 1, mean, na.rm=TRUE)\n  rw_quant = t(apply(rw_iter[,2:ncol(rw_iter)], 1,\n                     function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  rw_tree = data.frame(x_mean = rw_mean,\n                       x_median = rw_quant[,2],\n                       x_lo = rw_quant[,1],\n                       x_hi = rw_quant[,3],\n                       year = years[yrinds],\n                       model = 'RW')\n}\n\n\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\nif (in.RW){\n  idx_rw_obs = which(Xobs$stat_id == tree)\n  \n  rw_obs = data.frame(x_obs = Xobs$incr[idx_rw_obs],\n                      year = years[Xobs$year[idx_rw_obs]])\n} else {\n  rw_obs = data.frame(x_obs = numeric(0),\n                      year = numeric(0))\n}\n\np2 = ggplot() +\n  geom_ribbon(data=rw_tree, aes(x=year, ymin=x_lo, ymax=x_hi, fill=model), alpha=0.5) +\n  geom_line(data=rw_tree, aes(x=year, y=x_median, colour=model)) +\n  geom_point(data=rw_obs, aes(x=year, y=x_obs), size=2, alpha=0.4) +\n  xlab('year') +\n  ylab('rw (mm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  #+\n\ngrid.arrange(p1, p2, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n\n\nWe have looked at diagnostics of the model sampling step, but it is a good idea to do some additional model validation. This typically involved comparing model and data values. Here we will visualize model inferred versus observed diamater and increment.\nThe modelled and observed diameter and increment values have already been organized into data frames. We will load them in order to visualize the information.\nFirst we will look at the model versus data diameter scatter plot.\n\n\nCode\n# comparing estimates of diameter increment to observation\ndbh_validate = readRDS('output/DBH_VALIDATE_HARVARD.RDS')\ndbh_validate = subset(dbh_validate, model == 'RW')\n\np = ggplot(data=dbh_validate) +\n  geom_abline(intercept=0, slope=1, lty=2, colour='red') +\n  geom_linerange(aes(x=d_obs, ymin=d_model_lo, ymax=d_model_hi, colour=model), alpha=0.3) +\n  geom_point(aes(x=d_obs, y=d_model_median, colour=model), size=2, alpha=0.3) +\n  geom_line(stat='smooth', method='lm', formula = y ~ x, aes(x=d_obs, y=d_model_median), colour = 'blue', alpha=0.5, fullrange=TRUE) +\n  xlab('dbh obs (cm)') +\n  ylab('dbh model (cm)') +\n  theme_bw(16) +\n  coord_fixed() \nprint(p)\n\n\n\n\n\n\n\n\n\nNow we visualize the model versus data diameter using a scatter plot. The Blue line is the best-fit line through the median predictions vs. observations. Do you think this model is under or over estimating increment data?\n\n\nCode\nrw_validate = readRDS('output/RW_VALIDATE_HARVARD.RDS')\nrw_validate = subset(rw_validate, model == 'RW')\n\nq = ggplot(data=rw_validate) +\n  geom_abline(intercept=0, slope=1, lty=2, colour='red') +\n  geom_smooth(method='lm', aes(x=rw_obs, y=rw_model_median), fullrange=TRUE) +\n  geom_linerange(aes(x=rw_obs, ymin=rw_model_lo, ymax=rw_model_hi, colour=model), alpha=0.3) +\n  geom_point(aes(x=rw_obs, y=rw_model_median, colour=model), size=2, alpha=0.3) +\n  xlab('rw obs (mm)') +\n  ylab('rw model (mm)') +\n  theme_bw(16) \nprint(q)\n\n\n`geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#taxon-level-aboveground-biomass-agb-and-aboveground-biomass-increment-agbi",
    "href": "Module_5_RingWidth_only_model.html#taxon-level-aboveground-biomass-agb-and-aboveground-biomass-increment-agbi",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "Taxon-level Aboveground Biomass (AGB) and Aboveground Biomass Increment (AGBI)",
    "text": "Taxon-level Aboveground Biomass (AGB) and Aboveground Biomass Increment (AGBI)\n\n\nCode\nagb_taxon_by_iter = agb_melt %&gt;%\n  group_by(year, iter, taxon, plot, model) %&gt;% \n  # # sum up the taxon-level information by plot, iteration, year\n  summarise( AGB.taxon.plot = sum(value, na.rm =TRUE)) %&gt;% ungroup() %&gt;%\n  # \n  # get the mean value across plots for each iteration:\n  group_by(year, iter, taxon, model) %&gt;%\n   # dplyr::summarize(AGB.iter.mean = mean(value, na.rm = TRUE),\n   #                  .groups='keep')\n   dplyr::summarize(AGB.iter.mean = mean(AGB.taxon.plot, na.rm = TRUE),\n                     .groups='keep')\n\n\n`summarise()` has grouped output by 'year', 'iter', 'taxon', 'plot'. You can\noverride using the `.groups` argument.\n\n\nCode\nagb_taxon_summary = agb_taxon_by_iter %&gt;%ungroup() %&gt;% \n  group_by(year, taxon, model) %&gt;% \n  dplyr::summarize(AGB.mean = mean(AGB.iter.mean, na.rm = TRUE),\n                   AGB.sd = sd(AGB.iter.mean, na.rm=TRUE),\n                   AGB.lo = quantile(AGB.iter.mean, c(0.025), na.rm=TRUE),\n                   AGB.hi = quantile(AGB.iter.mean, c(0.975), na.rm=TRUE), \n                   .groups='keep')\n\nabi_taxon_by_iter = abi_melt %&gt;%\n  group_by(year, iter, taxon, plot, model) %&gt;% \n  summarise( AGBI.taxon.plot = sum(value, na.rm =TRUE)) %&gt;% ungroup() %&gt;%\n  group_by(year, iter, taxon, model) %&gt;% \n  dplyr::summarize(ABI.iter.mean = mean(AGBI.taxon.plot, na.rm = TRUE),\n                   .groups='keep')\n\n\n`summarise()` has grouped output by 'year', 'iter', 'taxon', 'plot'. You can\noverride using the `.groups` argument.\n\n\nCode\n#taxon summary data without plot \nabi_taxon_summary = abi_taxon_by_iter %&gt;% ungroup() %&gt;%\n  group_by(year, taxon, model) %&gt;% \n  dplyr::summarize(ABI.mean = mean(ABI.iter.mean, na.rm = TRUE),\n                   ABI.sd = sd(ABI.iter.mean, na.rm=TRUE),\n                   ABI.lo = quantile(ABI.iter.mean, c(0.025), na.rm=TRUE),\n                   ABI.hi = quantile(ABI.iter.mean, c(0.975), na.rm=TRUE), \n                   .groups='keep')\n\n\n\n\nCode\nggplot(data = agb_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=AGB.lo, ymax=AGB.hi, colour=taxon, fill=taxon), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = AGB.mean, color = taxon))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=ABI.lo, ymax=ABI.hi, colour=taxon, fill=taxon), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = ABI.mean, color = taxon))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass increment (mg/ha)')",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#stand-level-biomass-and-biomass-increment",
    "href": "Module_5_RingWidth_only_model.html#stand-level-biomass-and-biomass-increment",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "Stand-level Biomass and Biomass increment",
    "text": "Stand-level Biomass and Biomass increment\n\n\nCode\nagb_all_plot_by_iter &lt;- agb_melt |&gt;\n  group_by(year, iter, plot, model) |&gt;\n  # sums all of the trees by plot\n  dplyr::summarize(AGB.sum = sum(value),\n            .groups = 'keep') \n\nagb_site_by_iter &lt;- agb_all_plot_by_iter |&gt;\n  group_by(year, iter, model) |&gt;\n  dplyr::summarize(AGB.iter = mean(AGB.sum),\n                   .groups = 'keep') \n\nagb_site_summary = agb_site_by_iter %&gt;%\n  group_by(year, model) %&gt;%\n  dplyr::summarize(abmean = mean(AGB.iter, na.rm=T),\n    ab025 = quantile(AGB.iter, 0.025),\n                   ab50 = quantile(AGB.iter, 0.5),\n                   ab975 = quantile(AGB.iter, 0.975), \n                   .groups = 'keep') %&gt;% \n  ungroup()\n\n\n\nabi_all_plot_by_iter &lt;- abi_melt |&gt;\n  group_by(year, iter, plot, model) |&gt;\n  dplyr::summarize(ABI.sum = sum(value),\n            .groups = 'keep') \n\nabi_site_by_iter &lt;- abi_all_plot_by_iter |&gt;\n  group_by(year, iter, model) |&gt;\n  dplyr::summarize(ABI.iter = mean(ABI.sum),\n                   .groups = 'keep') \n\nabi_site_summary = abi_site_by_iter %&gt;%\n  group_by(year, model) %&gt;%\n  dplyr::summarize(abimean = mean(ABI.iter, na.rm=T),\n    abi025 = quantile(ABI.iter, 0.025),\n                   abi50 = quantile(ABI.iter, 0.5),\n                   abi975 = quantile(ABI.iter, 0.975), \n                   .groups = 'keep') %&gt;% \n  ungroup()\n\n\n\n\nCode\nggplot(data = agb_site_summary)+\n  geom_ribbon(aes(x=year, ymin=ab025, ymax=ab975), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abmean))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_site_summary)+\n  geom_ribbon(aes(x=year, ymin=abi025, ymax=abi975), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abimean))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_5_RingWidth_only_model.html#comparing-rw-only-model-to-our-data-based-estimates",
    "href": "Module_5_RingWidth_only_model.html#comparing-rw-only-model-to-our-data-based-estimates",
    "title": "Module 5: Ring-width only model (RW-only)",
    "section": "6. Comparing RW-only model to our data-based estimates",
    "text": "6. Comparing RW-only model to our data-based estimates\n\n\nCode\n# \n\nTR_AGB = readRDS('data/TR_AGB_ests_allodb.rds')\nTR_AGB$tree = allTrees$stat_id[match(TR_AGB$id, allTrees$ID)]\n\nTR_AGB = TR_AGB %&gt;% group_by(tree) %&gt;% \n  \n  arrange(cal.year) %&gt;% \n  \n  mutate(AGBI_kg = AGB_kg - lag(AGB_kg))\n\nhead(TR_AGB)\n\n\n# A tibble: 6 × 19\n# Groups:   tree [1]\n  cal.year cored.cal.year incr.avg id       dbh cum.diainc dia.inc  plot taxon\n     &lt;dbl&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n1     1861           2010     1.99 LF3017    50       43.5   0.398     3 ACRU \n2     1862           2010     3.01 LF3017    50       43.1   0.602     3 ACRU \n3     1863           2010     3.49 LF3017    50       42.5   0.698     3 ACRU \n4     1864           2010     3.02 LF3017    50       41.8   0.605     3 ACRU \n5     1865           2010     3.48 LF3017    50       41.2   0.696     3 ACRU \n6     1866           2010     2.55 LF3017    50       40.5   0.51      3 ACRU \n# ℹ 10 more variables: dbh_cm_bc &lt;dbl&gt;, SPCD &lt;dbl&gt;, COMMON_NAME &lt;chr&gt;,\n#   GENUS &lt;chr&gt;, SPECIES &lt;chr&gt;, `Scientific Name` &lt;chr&gt;, AGB_kg &lt;dbl&gt;,\n#   tph_corr &lt;dbl&gt;, tree &lt;int&gt;, AGBI_kg &lt;dbl&gt;\n\n\nCode\nTR_AGB_sub = subset(TR_AGB, tree==1)\n\n\np1 = ggplot() +\n  geom_ribbon(data = agb_tree_quants, aes(x = year, ymin = agb_lo, ymax = agb_hi, fill = model), alpha=0.5) +\n  geom_line(data=agb_tree_quants, aes(x=year, y=agb_median, colour = model)) +\n  geom_line(data=TR_AGB_sub, aes(x=cal.year, y=AGB_kg)) + \n  xlab('year') +\n  ylab('Tree Level Biomass (kg)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  +\n  # ggtitle(paste0('Tree ', i)) +\n  annotation_custom(grob)\nprint(p1)\n\n\n\n\n\n\n\n\n\nCode\np2 = ggplot() +\n  geom_ribbon(data = abi_tree_quants, aes(x = year, ymin = abi_lo, ymax = abi_hi, fill = model), alpha=0.5) +\n  geom_line(data=abi_tree_quants, aes(x=year, y=abi_median, colour = model)) +\n  geom_line(data=TR_AGB_sub, aes(x=cal.year, y=AGBI_kg)) + \n  xlab('year') +\n  ylab('Tree-level Biomass Increment (kg / year)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16) \nprint(p2)\n\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\n\n\nCode\nTAXA.AGB &lt;- TR_AGB %&gt;% group_by(taxon, COMMON_NAME, GENUS, SPECIES, cal.year, plot) %&gt;% \n  \n  summarise(AGB_Mg_ha_taxa_plot = sum(AGB_kg*tph_corr), \n            AGBI_Mg_ha_taxa_plot = sum(AGBI_kg*tph_corr)) %&gt;% \n  \n  filter(cal.year &lt;= 2010) %&gt;% \n  \n  ungroup() %&gt;% \n  \n  group_by(taxon, COMMON_NAME, GENUS, SPECIES, cal.year) %&gt;%\n  \n  summarise(AGB_Mg_ha_taxa = mean(AGB_Mg_ha_taxa_plot, na.rm = TRUE), \n            AGBI_Mg_ha_taxa = mean(AGBI_Mg_ha_taxa_plot, na.rm =TRUE)) #%&gt;%\n\n\n`summarise()` has grouped output by 'taxon', 'COMMON_NAME', 'GENUS', 'SPECIES',\n'cal.year'. You can override using the `.groups` argument.\n`summarise()` has grouped output by 'taxon', 'COMMON_NAME', 'GENUS', 'SPECIES'.\nYou can override using the `.groups` argument.\n\n\nCode\nsite.AGB &lt;- TR_AGB %&gt;% group_by(cal.year, plot) %&gt;% \n  \n  summarise(AGB_Mg_ha_plot = sum(AGB_kg*tph_corr), \n            AGBI_Mg_ha_plot = sum(AGBI_kg*tph_corr)) %&gt;% \n  \n  filter(cal.year &lt;= 2010) %&gt;% \n  \n  ungroup() %&gt;% \n  \n  group_by( cal.year) %&gt;%\n  \n  summarise(AGB_Mg_ha = mean(AGB_Mg_ha_plot, na.rm = TRUE), \n            AGBI_Mg_ha = mean(AGBI_Mg_ha_plot, na.rm =TRUE)) \n\n\n`summarise()` has grouped output by 'cal.year'. You can override using the\n`.groups` argument.\n\n\nCode\nggplot(data = agb_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=AGB.lo, ymax=AGB.hi, colour=taxon, fill=taxon), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = AGB.mean, color = taxon))+\n   geom_line(data = TAXA.AGB, aes(x = cal.year, y = AGB_Mg_ha_taxa), size = 1)+\n  #facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('Taxa Biomass (mg/ha)')+facet_wrap(~taxon, scales = \"free_y\")\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=ABI.lo, ymax=ABI.hi, colour=taxon, fill=taxon), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = ABI.mean, color = taxon))+\n  geom_line(data = TAXA.AGB, aes(x = cal.year, y = AGBI_Mg_ha_taxa), size = 1)+\n  #facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('Taxa Biomass Increment (mg/ha)')+facet_wrap(~taxon, scales = \"free_y\")\n\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\nCode\n# site -level AGB:\nggplot(data = agb_site_summary)+\n  geom_ribbon(aes(x=year, ymin=ab025, ymax=ab975), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abmean))+\n  geom_line(data = site.AGB, aes(x = cal.year, y = AGB_Mg_ha), linetype = 3)+\n  #facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('Site-level Biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_site_summary)+\n  geom_ribbon(aes(x=year, ymin=abi025, ymax=abi975), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abimean))+\n  geom_line(data = site.AGB, aes(x = cal.year, y = AGBI_Mg_ha), linetype = 3)+\n  #facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('Site-level Biomass Increment (mg/ha)')\n\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\nCode\nsaveRDS(abi_site_summary, \"summary/abi_site_summary_TR.RDS\")\nsaveRDS(agb_site_summary, \"summary/agb_site_summary_TR.RDS\")\n\nsaveRDS(abi_taxon_summary, \"summary/abi_taxon_summary_TR.RDS\")\nsaveRDS(agb_taxon_summary, \"summary/agb_taxon_summary_TR.RDS\")",
    "crumbs": [
      "Home",
      "Module 5: Ring-width only model (RW-only)"
    ]
  },
  {
    "objectID": "Module_7_RingWidth_and_Census.html#load-packages-to-be-used",
    "href": "Module_7_RingWidth_and_Census.html#load-packages-to-be-used",
    "title": "Module 6: Ring Width and Census Data Model (RW + Census)",
    "section": "Load packages to be used",
    "text": "Load packages to be used\nWe estimate the parameters of this state-space model in a program called stan which interfaces to R via a package called rstan (cmdstan is another package that is used.)\n\n\nCode\nlibrary(rstan)\nlibrary(dplyr)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(gridExtra)\nlibrary(tidyr)",
    "crumbs": [
      "Home",
      "Module 6: Ring Width and Census Data Model (RW + Census)"
    ]
  },
  {
    "objectID": "Module_7_RingWidth_and_Census.html#running-the-model-example-for-a-short-run",
    "href": "Module_7_RingWidth_and_Census.html#running-the-model-example-for-a-short-run",
    "title": "Module 6: Ring Width and Census Data Model (RW + Census)",
    "section": "Running the model: Example for a short run",
    "text": "Running the model: Example for a short run\n\n\nCode\n# settings\niter = 500\nnchains = 1\n\ncompiled_CENSUS = stan_model(file = paste0('models/growth_model_CENSUS.stan'))\n\nfit_CENSUS = sampling(compiled_CENSUS, \n                  data = dat, \n                  iter = iter, \n                  chains = nchains,\n                  verbose=TRUE)",
    "crumbs": [
      "Home",
      "Module 6: Ring Width and Census Data Model (RW + Census)"
    ]
  },
  {
    "objectID": "Module_7_RingWidth_and_Census.html#the-census-census-model-outputs",
    "href": "Module_7_RingWidth_and_Census.html#the-census-census-model-outputs",
    "title": "Module 6: Ring Width and Census Data Model (RW + Census)",
    "section": "The CENSUS + CENSUS model outputs",
    "text": "The CENSUS + CENSUS model outputs\nWe will load the output from the fitted model (fitted model object and parameter posterior distributions).\n\n\nCode\nvariables = names(post_RW_CENSUS[1,1,])\nallSX = grep('sig_x\\\\[',variables)\n\npost_sx = post_RW_CENSUS[,,allSX]\n\ndim(post_sx)\n\n\n[1] 250   9\n\n\nCode\ncolnames(post_sx) = taxa\npost_sx_melt = melt(post_sx)\ncolnames(post_sx_melt) = c('iteration', 'species_code', 'sigma_x')\npost_sx_melt$model = 'RW + CENSUS'\n\nsig_x_mean = post_sx_melt %&gt;% \n  group_by(species_code) %&gt;%\n  dplyr::summarize(sig_x_mean = mean(sigma_x))\nsig_x_mean = sig_x_mean[order(sig_x_mean$sig_x_mean),]\n\npost_sx_melt$species_code = factor(post_sx_melt$species_code, levels=sig_x_mean$species_code)\n\n# plot up the species level increment uncertainties\np = ggplot(data=post_sx_melt) +\n  # geom_boxplot(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  geom_violin(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  xlab('Species') +\n  ylab('sigma_x')\nprint(p)\n\n\n\n\n\n\n\n\n\n\n\nCode\nvariables = names(post_RW_CENSUS[1,1,])\nallSXOBS = grep('sig_x_obs',variables)\n\npost_sxobs = post_RW_CENSUS[,,allSXOBS]\n\n# head(post_sx)\n# dim(post_sx)\n\npost_sxobs = data.frame(post_sxobs)\npost_sxobs$iteration = seq(1, nrow(post_sxobs))\ncolnames(post_sxobs) = c('sigma_x_obs', 'iteration')\npost_sxobs$model = 'CENSUS-only'\nsaveRDS(post_sxobs, \"data/post_sxobs_CENSUS.rds\")\n\np = ggplot(data=post_sxobs) +\n  # geom_boxplot(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  geom_violin(aes(x=model, y=sigma_x_obs, colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  #xlab('Species') +\n  ylab('sigma_x')\nprint(p)\n\n\n\n\n\n\n\n\n\nCode\np = ggplot(data=post_sxobs) +\n  geom_histogram(aes(x=sigma_x_obs, y=after_stat(density), colour=model, fill=model)) +\n  theme_bw(14) \nprint(p)\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nCode\np = ggplot(data=post_sxobs) +\n  geom_line(aes(x=iteration, y=sigma_x_obs)) +\n  geom_point(aes(x=iteration, y=sigma_x_obs)) +\n  theme_bw(14) +\n  xlab('Iteration') +\n  ylab('sigma_x_obs') \nprint(p)",
    "crumbs": [
      "Home",
      "Module 6: Ring Width and Census Data Model (RW + Census)"
    ]
  },
  {
    "objectID": "Module_7_RingWidth_and_Census.html#visualizing-chronology-like-effects-year-random-effects",
    "href": "Module_7_RingWidth_and_Census.html#visualizing-chronology-like-effects-year-random-effects",
    "title": "Module 6: Ring Width and Census Data Model (RW + Census)",
    "section": "4. Visualizing chronology-like effects: year random effects",
    "text": "4. Visualizing chronology-like effects: year random effects\nHere we will also look at some summary figures for the beta_t parameter. For each species, there is a beta_t parameter for each year. This parameter is conceptually the same as a forest chronology; it is a time series that describes the common forest growth signal for a given species.\nWe could look at summary plots for the posterior samples for a given year for a given species, and do the same for all year BY species combinations. This would be (9 species) x (115 years) = 1035 trace plots, so we don’t look at all of them here.\nWe do want to visualize the beta_t chronology-like parameters as species-specific time series.\n\n\nCode\nallBTs = grep('beta_t\\\\[',variables)\npost_bt = post_RW_CENSUS[,,allBTs]\n\npost_bt_melt = melt(post_bt)\npost_bt_melt$model = 'RW + CENSUS'\n\nbt_pars_split = strsplit(as.vector(post_bt_melt$parameters), '\\\\[|\\\\,|\\\\]')\n\npost_bt_melt$species_code = taxa[sapply(bt_pars_split, function(x) as.numeric(x[[3]]))]\npost_bt_melt$year = years[sapply(bt_pars_split, function(x) as.numeric(x[[2]]))]\ncolnames(post_bt_melt) = c('iteration', 'parameter', 'beta_t', 'model', 'species_code', 'year')\n\nbeta_t_quant = post_bt_melt %&gt;% \n  group_by(model, species_code, year) %&gt;%\n  dplyr::summarize(beta_t_lo = quantile(beta_t, 0.025),\n                   beta_t_mid = quantile(beta_t, 0.5),\n                   beta_t_hi = quantile(beta_t, 0.975),\n                   beta_t_mean = mean(beta_t), \n                   .groups = 'keep')\n\np = ggplot(data=beta_t_quant) +\n  geom_hline(aes(yintercept=0), lty=2, lwd=1.2) +\n  geom_point(aes(x=year, y=beta_t_mid)) +\n  geom_linerange(aes(x=year, ymin=beta_t_lo, ymax=beta_t_hi)) +\n  xlab('year') +\n  ylab('beta_t') +\n  # xlim(c(year_lo, year_hi)) +\n  theme_bw(16) +\n  facet_grid(species_code~.)\nprint(p)\n\n\n\n\n\n\n\n\n\nHere we visualize inferred and observed diameter data for one tree (Tree 1). Filled circles indicate the diameter measurement included in this model and hollow circles are census diameter measurements not included in the model.\n\n\nCode\nallDs = grep('D\\\\[',variables)\npost_d = post_RW_CENSUS[,,allDs]\n\ntree = 1\n\n\n print(tree)\n\n\n[1] 1\n\n\nCode\n  in.RW = tree %in% X2Tr\n  \n  # if (in.RW){\n  #   inds = which(X2Tr == tree)\n  #   yrinds = X2year[inds]\n  #   \n  #   dbh_iter = t(post_d[[1]][,inds])\n  #   dbh_iter = data.frame(dbh_iter)\n  #   dbh_iter = data.frame(year=years[yrinds], dbh_iter)\n  #   \n  #   dbh_mean = apply(dbh_iter[,2:ncol(dbh_iter)], 1, mean, na.rm=TRUE)\n  #   dbh_quant = t(apply(dbh_iter[,2:ncol(dbh_iter)], 1, \n  #                       function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  #   \n  #   dbh_tree = data.frame(d_mean = dbh_mean, \n  #                         d_median = dbh_quant[,2], \n  #                         d_lo = dbh_quant[,1], \n  #                         d_hi = dbh_quant[,3], \n  #                         year = years[yrinds],\n  #                         model = 'RW')\n  #   \n  # }\n  \n  # determine which estimates correspond to this tree\n  inds_C = which(X2Tr_C == tree)\n  yrinds_C = X2year_C[inds_C]\n\n  # # C\n  # dbh_iter_C = t(post_d[,inds_C])\n  # dbh_iter_C = data.frame(dbh_iter_C)\n  # dbh_iter_C = data.frame(year=years[yrinds_C], dbh_iter_C)\n  # \n  # dbh_mean_C = apply(dbh_iter_C[,2:ncol(dbh_iter_C)], 1, mean, na.rm=TRUE)\n  # dbh_quant_C = t(apply(dbh_iter_C[,2:ncol(dbh_iter_C)], 1, \n  #                       function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  # \n  # dbh_tree_C = data.frame(d_mean = dbh_mean_C, \n  #                         d_median = dbh_quant_C[,2], \n  #                         d_lo = dbh_quant_C[,1], \n  #                         d_hi = dbh_quant_C[,3], \n  #                         year = years[yrinds_C],\n  #                         model = 'Census')\n\n    # RWC\n  dbh_iter_RWC &lt;- t(post_d[, inds_C])\n  dbh_iter_RWC = data.frame(dbh_iter_RWC)\n  dbh_iter_RWC = data.frame(year=years[yrinds_C], dbh_iter_RWC)\n  \n  dbh_mean_RWC = apply(dbh_iter_RWC[,2:ncol(dbh_iter_RWC)], 1, mean, na.rm=TRUE)\n  dbh_quant_RWC = t(apply(dbh_iter_RWC[,2:ncol(dbh_iter_RWC)], 1, \n                          function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  dbh_tree_RWC = data.frame(d_mean = dbh_mean_RWC, \n                            d_median = dbh_quant_RWC[,2], \n                            d_lo = dbh_quant_RWC[,1], \n                            d_hi = dbh_quant_RWC[,3], \n                            year = years[yrinds_C],\n                            model = 'RW + Census')\n\n  dbh_tree = dbh_tree_RWC\n  \n  idx_d_obs_C = which(Dobs$stat_id == tree)\n  \n  dbh_obs_C = data.frame(d_obs = Dobs$dbh[idx_d_obs_C],\n                         year = years[Dobs$year[idx_d_obs_C]])\n  \n  stem_id = Dobs$ID[idx_d_obs_C][1]\n  \n  if (in.RW){\n    idx_d_obs = which(Tr$stat_id == tree)\n    \n    dbh_obs = data.frame(d_obs = Tr$dbh[idx_d_obs],\n                         year = years[Tr$year[idx_d_obs]])\n    \n  } else {\n    dbh_obs = data.frame(d_obs = numeric(0),\n                         year = numeric(0))\n  }\n\n  \n# Create a text\ngrob = grobTree(textGrob(paste0('Tree ', tree, '; ID ', stem_id, '; Species ', taxon_C[tree] ), x=0.05,  y=0.9, hjust=0,\n                         gp=gpar(col=\"black\", fontsize=18)))\n\np1 = ggplot() +\n  geom_ribbon(data=dbh_tree, aes(x=year, ymin=d_lo, ymax=d_hi, fill=model), alpha=0.5) +\n  geom_line(data=dbh_tree, aes(x=year, y=d_median, colour=model)) +\n  geom_point(data=dbh_obs, aes(x=year, y=d_obs), size=2) +\n  geom_point(data=dbh_obs_C, aes(x=year, y=d_obs), size=2, shape=1) +\n  xlab('year') +\n  ylab('dbh (cm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  +\n  annotation_custom(grob)\n\nprint(p1)\n\n\n\n\n\n\n\n\n\n\n\nCode\nallRWs = grep('X\\\\[',variables)\npost_rw = post_RW_CENSUS[,,allRWs]\n\n\n  \n  inds_C = which(X2Tr_C == tree)\n  yrinds_C = X2year_C[inds_C]\n  \n  rw_iter_RWC = t(post_rw[,inds_C])\n  rw_iter_RWC = data.frame(rw_iter_RWC)\n  rw_iter_RWC = data.frame(year=years[yrinds_C], rw_iter_RWC)\n  \n  rw_mean_RWC = apply(rw_iter_RWC[,2:ncol(rw_iter_RWC)], 1, mean, na.rm=TRUE)\n  rw_quant_RWC = t(apply(rw_iter_RWC[,2:ncol(rw_iter_RWC)], 1, \n                         function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n  \n  rw_tree_RWC = data.frame(x_mean = rw_mean_RWC, \n                           x_median = rw_quant_RWC[,2], \n                           x_lo = rw_quant_RWC[,1], \n                           x_hi = rw_quant_RWC[,3], \n                           year = years[yrinds_C],\n                           model = 'RW + Census')\n\n  rw_tree = rw_tree_RWC\n  \n\n# if (in.RW){\n    idx_rw_obs = which(Xobs$stat_id == tree)\n    \n    rw_obs = data.frame(x_obs = Xobs$incr[idx_rw_obs],\n                        year = years[Xobs$year[idx_rw_obs]])\n # } else {\n  #   rw_obs = data.frame(x_obs = numeric(0),\n   #                      year = numeric(0))\n   #}\n\n\n  \n  \n\n# p2 = ggplot() +\n#   geom_ribbon(data= rw_tree_RWC, aes(x=year, ymin=x_lo, ymax=x_hi, fill=model), alpha=0.5) +\n#   geom_line(data= rw_tree_RWC, aes(x=year, y=x_median, colour=model)) +\n#   geom_point(data= rw_tree_RWC, aes(x=year, y=x_obs), size=2, alpha=0.4) +\n#   xlab('year') +\n#   ylab('CENSUS (mm)') +\n#   xlim(c(year_lo, year_hi)) +\n#   theme_bw(16)  #+\n# \n# grid.arrange(p1, p2, nrow = 2)\n\n  \n  p2 = ggplot() +\n    # geom_line(data=dbh_tree, aes(x=year, y=d_mean)) +\n    # geom_ribbon(data=rw_tree, aes(x=year, ymin=x_lo, ymax=x_hi), fill='lightgrey') +\n    geom_ribbon(data=rw_tree_RWC, aes(x=year, ymin=x_lo, ymax=x_hi, fill=model), alpha=0.5) +\n    geom_line(data=rw_tree_RWC, aes(x=year, y=x_median, colour=model)) +\n    geom_point(data=rw_obs, aes(x=year, y=x_obs), size=2, alpha=0.4) +\n    # geom_dog(data=rw_obs, aes(x=year, y=x_obs, dog='glasses'), size=2) +\n    # ylim(c(0,500)) +\n    xlab('year') +\n    ylab('rw (mm)') +\n    xlim(c(year_lo, year_hi)) +\n    theme_bw(16) \n  \n  print(p2)",
    "crumbs": [
      "Home",
      "Module 6: Ring Width and Census Data Model (RW + Census)"
    ]
  },
  {
    "objectID": "Module_7_RingWidth_and_Census.html#plot-of-agb-and-agbi-with-uncertainty",
    "href": "Module_7_RingWidth_and_Census.html#plot-of-agb-and-agbi-with-uncertainty",
    "title": "Module 6: Ring Width and Census Data Model (RW + Census)",
    "section": "Plot of AGB and AGBI with uncertainty",
    "text": "Plot of AGB and AGBI with uncertainty\n\n\nCode\n# melt down agb_array to data frame\nagb_melt = melt(agb_array_RWC)\ncolnames(agb_melt) = c('tree','year','iter','value')\nagb_melt = agb_melt %&gt;% filter(!is.na(value))\nagb_melt$year = years[agb_melt$year]\nagb_melt$plot = plot_C[agb_melt$tree]\nagb_melt$taxon = taxon_C[agb_melt$tree]\nagb_melt$model = rep(\"RW + CENSUS\", nrow(agb_melt))\nagb_melt$type = rep('ab',nrow(agb_melt))\n\n# first for CENSUS only model\nabi = apply(agb_array_RWC, c(1,3), function(x) diff(x))\nabi = aperm(abi, c(2, 1, 3))\nabi_melt = melt(abi)\ncolnames(abi_melt) = c('tree', 'year', 'iter', 'value')\nabi_melt = abi_melt %&gt;% filter(!is.na(value))\nabi_melt$year = years[abi_melt$year]\nabi_melt$plot = plot_C[abi_melt$tree]\nabi_melt$taxon = taxon_C[abi_melt$tree]\nabi_melt$model = rep(\"RW + CENSUS\", nrow(abi_melt))\nabi_melt$type = rep('abi',nrow(abi_melt))",
    "crumbs": [
      "Home",
      "Module 6: Ring Width and Census Data Model (RW + Census)"
    ]
  },
  {
    "objectID": "Module_7_RingWidth_and_Census.html#taxon-level-aboveground-biomass-agb-and-aboveground-biomass-increment-agbi",
    "href": "Module_7_RingWidth_and_Census.html#taxon-level-aboveground-biomass-agb-and-aboveground-biomass-increment-agbi",
    "title": "Module 6: Ring Width and Census Data Model (RW + Census)",
    "section": "Taxon-level Aboveground Biomass (AGB) and Aboveground Biomass Increment (AGBI)",
    "text": "Taxon-level Aboveground Biomass (AGB) and Aboveground Biomass Increment (AGBI)\n\n\nCode\nagb_taxon_by_iter = agb_melt %&gt;%\n  group_by(year, iter, taxon, plot, model) %&gt;% \n  # # sum up the taxon-level information by plot, iteration, year\n  summarise( AGB.taxon.plot = sum(value, na.rm =TRUE)) %&gt;% ungroup() %&gt;%\n  # \n  # get the mean value across plots for each iteration:\n  group_by(year, iter, taxon, model) %&gt;%\n   # dplyr::summarize(AGB.iter.mean = mean(value, na.rm = TRUE),\n   #                  .groups='keep')\n   dplyr::summarize(AGB.iter.mean = mean(AGB.taxon.plot, na.rm = TRUE),\n                     .groups='keep')\n\n\n`summarise()` has grouped output by 'year', 'iter', 'taxon', 'plot'. You can\noverride using the `.groups` argument.\n\n\nCode\nagb_taxon_summary = agb_taxon_by_iter %&gt;%ungroup() %&gt;% \n  group_by(year, taxon, model) %&gt;% \n  dplyr::summarize(AGB.mean = mean(AGB.iter.mean, na.rm = TRUE),\n                   AGB.sd = sd(AGB.iter.mean, na.rm=TRUE),\n                   AGB.lo = quantile(AGB.iter.mean, c(0.025), na.rm=TRUE),\n                   AGB.hi = quantile(AGB.iter.mean, c(0.975), na.rm=TRUE), \n                   .groups='keep')\n\nabi_taxon_by_iter = abi_melt %&gt;%\n  group_by(year, iter, taxon, plot, model) %&gt;% \n  summarise( AGBI.taxon.plot = sum(value, na.rm =TRUE)) %&gt;% ungroup() %&gt;%\n  group_by(year, iter, taxon, model) %&gt;% \n  dplyr::summarize(ABI.iter.mean = mean(AGBI.taxon.plot, na.rm = TRUE),\n                   .groups='keep')\n\n\n`summarise()` has grouped output by 'year', 'iter', 'taxon', 'plot'. You can\noverride using the `.groups` argument.\n\n\nCode\n#taxon summary data without plot \nabi_taxon_summary = abi_taxon_by_iter %&gt;% ungroup() %&gt;%\n  group_by(year, taxon, model) %&gt;% \n  dplyr::summarize(ABI.mean = mean(ABI.iter.mean, na.rm = TRUE),\n                   ABI.sd = sd(ABI.iter.mean, na.rm=TRUE),\n                   ABI.lo = quantile(ABI.iter.mean, c(0.025), na.rm=TRUE),\n                   ABI.hi = quantile(ABI.iter.mean, c(0.975), na.rm=TRUE), \n                   .groups='keep')\n\n\n\n\nCode\nggplot(data = agb_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=AGB.lo, ymax=AGB.hi, colour=taxon, fill=taxon), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = AGB.mean, color = taxon))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=ABI.lo, ymax=ABI.hi, colour=taxon, fill=taxon), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = ABI.mean, color = taxon))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass increment (mg/ha)')",
    "crumbs": [
      "Home",
      "Module 6: Ring Width and Census Data Model (RW + Census)"
    ]
  },
  {
    "objectID": "Module_7_RingWidth_and_Census.html#stand-level-biomass-and-biomass-increment",
    "href": "Module_7_RingWidth_and_Census.html#stand-level-biomass-and-biomass-increment",
    "title": "Module 6: Ring Width and Census Data Model (RW + Census)",
    "section": "Stand-level Biomass and Biomass increment",
    "text": "Stand-level Biomass and Biomass increment\n\n\nCode\nagb_all_plot_by_iter &lt;- agb_melt |&gt;\n  group_by(year, iter, plot, model) |&gt;\n  # sums all of the trees by plot\n  dplyr::summarize(AGB.sum = sum(value),\n            .groups = 'keep') \n\nagb_site_by_iter &lt;- agb_all_plot_by_iter |&gt;\n  group_by(year, iter, model) |&gt;\n  dplyr::summarize(AGB.iter = mean(AGB.sum),\n                   .groups = 'keep') \n\nagb_site_summary = agb_site_by_iter %&gt;%\n  group_by(year, model) %&gt;%\n  dplyr::summarize(abmean = mean(AGB.iter, na.rm=T),\n    ab025 = quantile(AGB.iter, 0.025),\n                   ab50 = quantile(AGB.iter, 0.5),\n                   ab975 = quantile(AGB.iter, 0.975), \n                   .groups = 'keep') %&gt;% \n  ungroup()\n\n\n\nabi_all_plot_by_iter &lt;- abi_melt |&gt;\n  group_by(year, iter, plot, model) |&gt;\n  dplyr::summarize(ABI.sum = sum(value),\n            .groups = 'keep') \n\nabi_site_by_iter &lt;- abi_all_plot_by_iter |&gt;\n  group_by(year, iter, model) |&gt;\n  dplyr::summarize(ABI.iter = mean(ABI.sum),\n                   .groups = 'keep') \n\nabi_site_summary = abi_site_by_iter %&gt;%\n  group_by(year, model) %&gt;%\n  dplyr::summarize(abimean = mean(ABI.iter, na.rm=T),\n    abi025 = quantile(ABI.iter, 0.025),\n                   abi50 = quantile(ABI.iter, 0.5),\n                   abi975 = quantile(ABI.iter, 0.975), \n                   .groups = 'keep') %&gt;% \n  ungroup()\n\n\n\n\nCode\nggplot(data = agb_site_summary)+\n  geom_ribbon(aes(x=year, ymin=ab025, ymax=ab975), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abmean))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_site_summary)+\n  geom_ribbon(aes(x=year, ymin=abi025, ymax=abi975), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abimean))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\nCode\nsaveRDS(abi_site_summary, \"summary/abi_site_summary_TR_CENSUS.RDS\")\nsaveRDS(agb_site_summary, \"summary/agb_site_summary_TR_CENSUS.RDS\")\n\nsaveRDS(abi_taxon_summary, \"summary/abi_taxon_summary_TR_CENSUS.RDS\")\nsaveRDS(agb_taxon_summary, \"summary/agb_taxon_summary_TR_CENSUS.RDS\")",
    "crumbs": [
      "Home",
      "Module 6: Ring Width and Census Data Model (RW + Census)"
    ]
  },
  {
    "objectID": "Module_8_Comparing_Biomass_Estimates.html",
    "href": "Module_8_Comparing_Biomass_Estimates.html",
    "title": "Module 7: Comparing RW only, the Census only, and RW + Census model",
    "section": "",
    "text": "Read in the outputs\nCompare Total Aboveground Biomass over time for each method (data-only estimates, TR only model, TR + census model)\nCompare Aboveground Biomass Increment over time for each method (data-only estimates, TR only model, TR + census model)\nRelating AGBI estimates to climate drivers\n\n\n\nCode\nlibrary(rstan)\nlibrary(dplyr)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(gridExtra)\nlibrary(tidyr)",
    "crumbs": [
      "Home",
      "Module 7: Comparing RW only, the Census only, and RW + Census model"
    ]
  },
  {
    "objectID": "Module_8_Comparing_Biomass_Estimates.html#outline",
    "href": "Module_8_Comparing_Biomass_Estimates.html#outline",
    "title": "Module 7: Comparing RW only, the Census only, and RW + Census model",
    "section": "",
    "text": "Read in the outputs\nCompare Total Aboveground Biomass over time for each method (data-only estimates, TR only model, TR + census model)\nCompare Aboveground Biomass Increment over time for each method (data-only estimates, TR only model, TR + census model)\nRelating AGBI estimates to climate drivers\n\n\n\nCode\nlibrary(rstan)\nlibrary(dplyr)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(gridExtra)\nlibrary(tidyr)",
    "crumbs": [
      "Home",
      "Module 7: Comparing RW only, the Census only, and RW + Census model"
    ]
  },
  {
    "objectID": "Module_8_Comparing_Biomass_Estimates.html#taxon-level-aboveground-biomass-agb-and-aboveground-biomass-increment-agbi",
    "href": "Module_8_Comparing_Biomass_Estimates.html#taxon-level-aboveground-biomass-agb-and-aboveground-biomass-increment-agbi",
    "title": "Module 7: Comparing RW only, the Census only, and RW + Census model",
    "section": "Taxon-level Aboveground Biomass (AGB) and Aboveground Biomass Increment (AGBI)",
    "text": "Taxon-level Aboveground Biomass (AGB) and Aboveground Biomass Increment (AGBI)\n\n\nCode\nagb_site_summary &lt;- rbind(agb_site_TR, agb_site_CENSUS, agb_site_TR_CENSUS)\nabi_site_summary &lt;- rbind(abi_site_TR, abi_site_CENSUS, abi_site_TR_CENSUS)\n\nagb_taxon_summary &lt;- rbind(agb_taxon_TR, agb_taxon_CENSUS, agb_taxon_TR_CENSUS)\nabi_taxon_summary &lt;- rbind(abi_taxon_TR, abi_taxon_CENSUS, abi_taxon_TR_CENSUS)\n\n\n\n\nCode\nggplot(data = agb_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=AGB.lo, ymax=AGB.hi, colour=model, fill=model), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = AGB.mean, color = model))+\n  facet_grid(taxon~., scales='free_y') +\n  theme_light(18) +\n  ylab('Taxa Aboveground Biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=ABI.lo, ymax=ABI.hi, colour=model, fill=model), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = ABI.mean, color = model))+\n  facet_grid(taxon~., scales='free_y') +\n  theme_light(18) +\n  ylab('Taxa biomass increment (mg/ha)')",
    "crumbs": [
      "Home",
      "Module 7: Comparing RW only, the Census only, and RW + Census model"
    ]
  },
  {
    "objectID": "Module_8_Comparing_Biomass_Estimates.html#stand-level-biomass-and-biomass-increment",
    "href": "Module_8_Comparing_Biomass_Estimates.html#stand-level-biomass-and-biomass-increment",
    "title": "Module 7: Comparing RW only, the Census only, and RW + Census model",
    "section": "Stand-level Biomass and Biomass increment",
    "text": "Stand-level Biomass and Biomass increment\n\nPlot up stand-scale AGB over time for each method\n\n\nCode\nggplot(data = agb_site_summary)+\n  geom_ribbon(aes(x=year, ymin=ab025, ymax=ab975, fill = model), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abmean, color = model))+\n  #facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\n\n\nPlot up stand-scale AGBI over time for each method\n\n\nCode\nggplot(data = abi_site_summary)+\n  geom_ribbon(aes(x=year, ymin=abi025, ymax=abi975, fill = model), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abimean, color = model))+\n  #facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass increment (mg/ha)')",
    "crumbs": [
      "Home",
      "Module 7: Comparing RW only, the Census only, and RW + Census model"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html",
    "href": "Module_4_Growth_model_Introduction.html",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "We are using Bayesian statistical inference to estimate tree growth given RW and/or Census data. This workflow is motivated by the desire to: account for and quantify the uncertainty in our understanding (of data and processes) of tree growth; integrate multiple data types that inform about tree growth; and using a framework that allows for estimation of growth for trees with incomplete data.\nBayesian inference makes it possible to achieve these objectives.\n\n\nThere are two types of observations of tree growth considered here: RW and Census.\nThe ring width datasets we are working with contain both ring-width time series from one or more tree cores and dbh at the time of coring. The census datasets contain repeat dbh measurements for some number of trees. Census remeasurement intervals are often 5-10 years.\nSo in short: RW data is annually resolved, while census data is not.\n\n\n\n\n\nWe denote the ring-width observations by \\(\\text{Robs}\\). For tree number \\(i\\), core \\(j\\), and year \\(t\\), the observed ring-width is represented by \\(\\text{Robs}_{i, j, t}\\).\nNote that not all trees need to have RW observations for all years in this framework (so it’s not a problem that the temporal extent of the ring-width time series vary among trees), and not all trees need to have the same number of cores.\n\n\n\nWe denote the diameter observations by \\(\\text{Dobs}\\). For tree number \\(i\\) and year \\(t\\), the observed diameter is represented by \\(\\text{Dobs}_{i, t}\\).\nNow we note that not all trees need have diameter observations for each year, and the years for which trees do have measurements need not be the same among all trees.\nAlso, if it were the case that diameter was measured multiple times when census (for example if each of the three field techs measured the diameter of each tree), then we could include an additional subscript as we did for the ring-width observations.\n\n\n\n\nThe objective is to quantify tree growth with uncertainty. We assume that there are some latent (unobserved) states that represent what we sometimes call the true increment and diameter. This description itself isn’t quite the truth (pun intended). These latent states quantify the best estimate of increment and diameter given the data and model. Tree growth isn’t perfectly circular; for a given year, ring-width might vary among cores.\n\n\nWe denote the latent increment by \\(\\text{R}\\). For tree number \\(i\\), and year \\(t\\), the latent increment is represented by \\(\\text{R}_{i, t}\\).\n\n\n\nWe denote the latent diameter by \\(\\text{D}\\). For tree number \\(i\\), and year \\(t\\), the latent diameter is represented by \\(\\text{D}_{i, t}\\).\n\n\n\n\n\n\n\nWe account for observation uncertainty in both the RW and diameter data. This uncertainty represents not only measurement uncertainty, but also uncertainty related to processes that result in observations that vary around the latent increment and diameter. For example, asymmetric growth processes.\nBoth increment and diameter observations vary around distributions with a central tendency determined by the latent increment and diameter, and with spread (dispersion) determined by parameters \\(\\sigma_\\text{Xobs}\\) and \\(\\sigma_\\text{Dobs}\\).\nMore formally we write\n\\(\\text{Robs}_{i, j, t} \\sim [\\text{R}_{i, t}, \\sigma_\\text{Xobs}]\\)\nand\n\\(\\text{Dobs}_{i, t} \\sim [\\text{D}_{i, t}, \\sigma_\\text{Dobs}]\\).\n\n\n\n\n\n\nIn this workflow, latent increment is distributed with a central tendency that is the sum of a tree specific effect (\\(\\beta_i\\), for tree \\(i\\)) and a species-time effect (\\(\\beta_{t, k}\\)), and a spread (dispersion) described by \\(\\sigma_{\\text{x}}\\).\nThis species-time effect \\(\\beta_{t, k}\\) is analogous to a forest growth chronology: it describes the common growth signal through time for each species.\nThis increment model can be extended to account for additional processes that determine annual growth. For example, we could include size, competition, or climate effects.\nUsing statistical notation, we write that\n\\(\\text{R}_{i, t} \\sim [\\beta_i + \\beta_{t, k}, \\sigma_{\\text{x}}]\\)\nThen, latent diameter for tree \\(i\\) at time \\(t\\), \\(\\text{D}_{i, t}\\) is a deterministic function equal to the diameter of that tree from the previous year, \\(\\text{D}_{i, t-1}\\), plus twice the increment \\(\\text{R}_{i, t}\\) (making sure the units are consistent). In formal notation, we have\n\\(\\text{D}_{i, t} = \\text{D}_{i, t-1} + 2 \\cdot \\text{R}_{i, t}\\).\n\n\n\n\n\n\n\n\n\nIn Bayesian inference, the posterior distribution which describes \\(P(model|data)\\) is proportional to the likelihood \\(P(data|model)\\) times the prior \\(P(model)\\). We need to define prior distributions for model parameters. There are many different ways to define prior distributions.\nFor example,\n\\(\\beta_i \\sim \\text{normal}(\\beta_0, \\beta_\\text{SD})\\) and\n\\(\\beta_0 \\sim \\text{normal}(0, 1000)\\) and\n\\(\\beta_\\text{SD} \\sim \\text{uniform}(0, 1000)\\).\nOther model parameters also require defined prior distributions.\n\n\n\nAfter formulating the Bayesian state space model, we would like to be able to infer the parameter posterior distributions. In a Bayesian paradigm, this typically requires using a sampling algorithm- a set of rules that we follow to get posterior distribution samples. There are different algorithms we can use, and different software that implements these algorithms.\nMost algorithms rely on a markov chain monte carlo algorithm. These algorithms involve iteratively: proposing new states (parameters), using a predefined criterion to decide if they are accepted, and either moving to this state (acceptance) or remaining in the current state (rejected). This iterative process is repeated many times, and makes it possible to explore the posterior distribution. The result is a set of posterior samples used to make inference about the parameters of interest.\n\n\n\nHere we use the statistical software Stan to estimate parameters. Stan interfaces to R via a package called rstan (cmdstan is another package that is used.)\nStan by default uses something called the Hamiltonian Monte Carlo sampling algorithm.\nIn this workshop, we are going to implement the model ourselves using Stan. To do this, we need a model written in Stan (file with .stan extension). Then we will fit this model using the RStan interface (R script). To use Stan, the model needs to be written in the Stan language (a text file with a .stan extension). A Stan model has three required blocks:\n\ndata block: declare data types, their dimensions, restrictions, and names.\nparameters block: declare parameter types, dimensions, restrictions, and names.\nmodel block: include sampling statements.\n\nWe won’t talk to much about the NUTS and bolts of STAN programming in this workshop, refer to: Stan language manual. (Stan uses what is called a NUTS algorithm so this is a terrible pun.)\n\n\n\n\n\n\ndata {\n  int&lt;lower=1&gt; N; // number of observations\n  vector[N] x;    // the predictor \n  vector[N] y;    // the outcome\n} \n\n\n\n\n\nparameters {\n  real alpha;  // intercept\n  real beta;   // slope\n  real&lt;lower=0&gt; sigma; // standard deviation\n}\n\n\n\n\n\nmodel {\n  \n  // priors\n  alpha ~ normal(0, 10);\n  beta  ~ normal(0, 10);  // priors for beta\n  sigma ~ cauchy(0, 5);  // prior for sigma\n  \n  // likelihood\n  y ~ normal(alpha+beta*x, sigma);\n}",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html#observed-growth",
    "href": "Module_4_Growth_model_Introduction.html#observed-growth",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "There are two types of observations of tree growth considered here: RW and Census.\nThe ring width datasets we are working with contain both ring-width time series from one or more tree cores and dbh at the time of coring. The census datasets contain repeat dbh measurements for some number of trees. Census remeasurement intervals are often 5-10 years.\nSo in short: RW data is annually resolved, while census data is not.\n\n\n\n\n\nWe denote the ring-width observations by \\(\\text{Robs}\\). For tree number \\(i\\), core \\(j\\), and year \\(t\\), the observed ring-width is represented by \\(\\text{Robs}_{i, j, t}\\).\nNote that not all trees need to have RW observations for all years in this framework (so it’s not a problem that the temporal extent of the ring-width time series vary among trees), and not all trees need to have the same number of cores.\n\n\n\nWe denote the diameter observations by \\(\\text{Dobs}\\). For tree number \\(i\\) and year \\(t\\), the observed diameter is represented by \\(\\text{Dobs}_{i, t}\\).\nNow we note that not all trees need have diameter observations for each year, and the years for which trees do have measurements need not be the same among all trees.\nAlso, if it were the case that diameter was measured multiple times when census (for example if each of the three field techs measured the diameter of each tree), then we could include an additional subscript as we did for the ring-width observations.",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html#inferred-growth",
    "href": "Module_4_Growth_model_Introduction.html#inferred-growth",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "The objective is to quantify tree growth with uncertainty. We assume that there are some latent (unobserved) states that represent what we sometimes call the true increment and diameter. This description itself isn’t quite the truth (pun intended). These latent states quantify the best estimate of increment and diameter given the data and model. Tree growth isn’t perfectly circular; for a given year, ring-width might vary among cores.\n\n\nWe denote the latent increment by \\(\\text{R}\\). For tree number \\(i\\), and year \\(t\\), the latent increment is represented by \\(\\text{R}_{i, t}\\).\n\n\n\nWe denote the latent diameter by \\(\\text{D}\\). For tree number \\(i\\), and year \\(t\\), the latent diameter is represented by \\(\\text{D}_{i, t}\\).",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html#observation-uncertainty",
    "href": "Module_4_Growth_model_Introduction.html#observation-uncertainty",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "We account for observation uncertainty in both the RW and diameter data. This uncertainty represents not only measurement uncertainty, but also uncertainty related to processes that result in observations that vary around the latent increment and diameter. For example, asymmetric growth processes.\nBoth increment and diameter observations vary around distributions with a central tendency determined by the latent increment and diameter, and with spread (dispersion) determined by parameters \\(\\sigma_\\text{Xobs}\\) and \\(\\sigma_\\text{Dobs}\\).\nMore formally we write\n\\(\\text{Robs}_{i, j, t} \\sim [\\text{R}_{i, t}, \\sigma_\\text{Xobs}]\\)\nand\n\\(\\text{Dobs}_{i, t} \\sim [\\text{D}_{i, t}, \\sigma_\\text{Dobs}]\\).",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html#growth-process",
    "href": "Module_4_Growth_model_Introduction.html#growth-process",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "In this workflow, latent increment is distributed with a central tendency that is the sum of a tree specific effect (\\(\\beta_i\\), for tree \\(i\\)) and a species-time effect (\\(\\beta_{t, k}\\)), and a spread (dispersion) described by \\(\\sigma_{\\text{x}}\\).\nThis species-time effect \\(\\beta_{t, k}\\) is analogous to a forest growth chronology: it describes the common growth signal through time for each species.\nThis increment model can be extended to account for additional processes that determine annual growth. For example, we could include size, competition, or climate effects.\nUsing statistical notation, we write that\n\\(\\text{R}_{i, t} \\sim [\\beta_i + \\beta_{t, k}, \\sigma_{\\text{x}}]\\)\nThen, latent diameter for tree \\(i\\) at time \\(t\\), \\(\\text{D}_{i, t}\\) is a deterministic function equal to the diameter of that tree from the previous year, \\(\\text{D}_{i, t-1}\\), plus twice the increment \\(\\text{R}_{i, t}\\) (making sure the units are consistent). In formal notation, we have\n\\(\\text{D}_{i, t} = \\text{D}_{i, t-1} + 2 \\cdot \\text{R}_{i, t}\\).",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html#priors",
    "href": "Module_4_Growth_model_Introduction.html#priors",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "In Bayesian inference, the posterior distribution which describes \\(P(model|data)\\) is proportional to the likelihood \\(P(data|model)\\) times the prior \\(P(model)\\). We need to define prior distributions for model parameters. There are many different ways to define prior distributions.\nFor example,\n\\(\\beta_i \\sim \\text{normal}(\\beta_0, \\beta_\\text{SD})\\) and\n\\(\\beta_0 \\sim \\text{normal}(0, 1000)\\) and\n\\(\\beta_\\text{SD} \\sim \\text{uniform}(0, 1000)\\).\nOther model parameters also require defined prior distributions.",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html#parameter-estimation",
    "href": "Module_4_Growth_model_Introduction.html#parameter-estimation",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "After formulating the Bayesian state space model, we would like to be able to infer the parameter posterior distributions. In a Bayesian paradigm, this typically requires using a sampling algorithm- a set of rules that we follow to get posterior distribution samples. There are different algorithms we can use, and different software that implements these algorithms.\nMost algorithms rely on a markov chain monte carlo algorithm. These algorithms involve iteratively: proposing new states (parameters), using a predefined criterion to decide if they are accepted, and either moving to this state (acceptance) or remaining in the current state (rejected). This iterative process is repeated many times, and makes it possible to explore the posterior distribution. The result is a set of posterior samples used to make inference about the parameters of interest.",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html#stan",
    "href": "Module_4_Growth_model_Introduction.html#stan",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "Here we use the statistical software Stan to estimate parameters. Stan interfaces to R via a package called rstan (cmdstan is another package that is used.)\nStan by default uses something called the Hamiltonian Monte Carlo sampling algorithm.\nIn this workshop, we are going to implement the model ourselves using Stan. To do this, we need a model written in Stan (file with .stan extension). Then we will fit this model using the RStan interface (R script). To use Stan, the model needs to be written in the Stan language (a text file with a .stan extension). A Stan model has three required blocks:\n\ndata block: declare data types, their dimensions, restrictions, and names.\nparameters block: declare parameter types, dimensions, restrictions, and names.\nmodel block: include sampling statements.\n\nWe won’t talk to much about the NUTS and bolts of STAN programming in this workshop, refer to: Stan language manual. (Stan uses what is called a NUTS algorithm so this is a terrible pun.)",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "Module_4_Growth_model_Introduction.html#example-linear-regression-model-specification",
    "href": "Module_4_Growth_model_Introduction.html#example-linear-regression-model-specification",
    "title": "Module 4: Model Introduction",
    "section": "",
    "text": "data {\n  int&lt;lower=1&gt; N; // number of observations\n  vector[N] x;    // the predictor \n  vector[N] y;    // the outcome\n} \n\n\n\n\n\nparameters {\n  real alpha;  // intercept\n  real beta;   // slope\n  real&lt;lower=0&gt; sigma; // standard deviation\n}\n\n\n\n\n\nmodel {\n  \n  // priors\n  alpha ~ normal(0, 10);\n  beta  ~ normal(0, 10);  // priors for beta\n  sigma ~ cauchy(0, 5);  // prior for sigma\n  \n  // likelihood\n  y ~ normal(alpha+beta*x, sigma);\n}",
    "crumbs": [
      "Home",
      "Module 4: Model Introduction"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome and Schedule",
    "section": "",
    "text": "This repository contains the material for the Workshop “Forest growth and carbon with uncertainty from tree-rings and census data” taught at World Dendro on Sunday, 27th July 2025.",
    "crumbs": [
      "Home",
      "Welcome and Schedule"
    ]
  },
  {
    "objectID": "index.html#welcome-to-the-workshop-forest-growth-and-carbon-with-uncertainty-from-tree-rings-and-census-data",
    "href": "index.html#welcome-to-the-workshop-forest-growth-and-carbon-with-uncertainty-from-tree-rings-and-census-data",
    "title": "Welcome and Schedule",
    "section": "",
    "text": "This repository contains the material for the Workshop “Forest growth and carbon with uncertainty from tree-rings and census data” taught at World Dendro on Sunday, 27th July 2025.",
    "crumbs": [
      "Home",
      "Welcome and Schedule"
    ]
  },
  {
    "objectID": "index.html#objectives",
    "href": "index.html#objectives",
    "title": "Welcome and Schedule",
    "section": "Objectives",
    "text": "Objectives\nIn this workshop we will introduce and work with a Bayesian statistical modelling framework to:\n\nuse tree-ring data to estimate annual tree diameter growth with uncertainty\nintegrate tree-ring data with forest census data to estimate annual growth for all trees on the plot (i.e. those with and without tree ring data)\nshow how this approach can directly link annual growth to climate and other drivers, and\nscale annual growth to carbon accumulation. \n\nWe will work through examples developed in R and RStudio. Experience with R is helpful but not required. All are welcome.",
    "crumbs": [
      "Home",
      "Welcome and Schedule"
    ]
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Welcome and Schedule",
    "section": "Schedule",
    "text": "Schedule\n\n\n\n\n\n\n\n\nTime\nTopic\nPresenter\n\n\n\n\n9:00 - 10:00\nModule 1: Introduction\nKelly, Andria, Ruby\n\n\n10:00 - 10:30\nModule 2: Tree Ring and Census Data\nKelly\n\n\n10:30 - 11:00\nModule 3: Biomass Estimation\nKelly\n\n\n11:00 - 11:15\nCoffee/Tea break?\n\n\n\n11:15 - 12:00\nModule 4: Tree ring only model\nAndria\n\n\n11:30 - 12:00\nModule 5: Tree ring and forest census model\nAndria\n\n\n12:00 - 12:30\nModule 6: Comparing Biomass Estimates\nAndria/Kelly\n\n\n12:30 - 1:30\nLunch",
    "crumbs": [
      "Home",
      "Welcome and Schedule"
    ]
  },
  {
    "objectID": "index.html#two-options-for-how-to-work-through-this-workshop",
    "href": "index.html#two-options-for-how-to-work-through-this-workshop",
    "title": "Welcome and Schedule",
    "section": "Two options for how to work through this workshop:",
    "text": "Two options for how to work through this workshop:\n\nNo-code: Work though on this website\nRunning .qmd files on Posit Cloud–.qmd files can be run similarly to rmarkdown files\n\nFollow these Instructions for getting started with this tutorial on POSIT cloud.",
    "crumbs": [
      "Home",
      "Welcome and Schedule"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This workshop was developed by Kelly A. Heilman and Andria Dawson in preparation for a workshop associated with the World Dendro conference in Zambia in July-August of 2025",
    "crumbs": [
      "Home",
      "About"
    ]
  },
  {
    "objectID": "Module_1_Introduction.html",
    "href": "Module_1_Introduction.html",
    "title": "Module 1: Introduction",
    "section": "",
    "text": "In this workshop we will introduce and work with a Bayesian statistical modelling framework to:\n\nuse tree-ring data to estimate annual tree diameter growth with uncertainty\nintegrate tree-ring data with forest census data to estimate annual growth for all trees on the plot (i.e. those with and without tree ring data)\nshow how this approach can directly link annual growth to climate and other drivers, and\nscale annual growth to carbon accumulation. \n\nWe will work through examples developed in R and RStudio. Experience with R is helpful but not required. All are welcome.\n\n\n\n\n\nManaging forests to increase carbon uptake and storage is among the proposed carbon drawdown strategies. Tree-ring data makes it possible to quantify annual tree growth and carbon accumulation. While annually resolved, determining forest carbon accumulation from tree-rings requires complete sampling, or a set of assumptions that limit reliability. Tree-ring datasets are also subject to the fading record problem– they do not capture mortality processes.\nForest censuses, which re-measure individual trees over time, (e.g. Nationwide forest inventories (NFIs), ForestGEO plots, etc), provide snapshots of stand-level dynamics (forest growth, mortality, and recruitment processes) and thus forest carbon. This census data often lacks the annual temporal resolution needed to understand patterns and attribute forest carbon accumulation drivers. Participants of this workshop will learn how tree ring data alone, and tree ring data in combination with forest census data can be used to estimate forest carbon.\n\n\n\n\n\n\nEstimates of forest carbon and tree-level biomass over time are useful for a variety of applications, including: -understanding drivers of growth and mortality -quantifying the relative roles of growth, mortality, and regeneration in driving forest C over time\n\n\n\n\nWe will work through a series of modules\n\nIntroduction & how to work through this tutorial (i.e. this page)\nIntroduction of Harvard Forest Census and Tree Ring Data\nEstimating Biomass from Ring width & Census data (no uncertainty)\nBayesian Growth Model Introduction\nRing-width only model\nCENSUS only model\nRing-width + CENSUS data\nComparing all three estimates\n\n\n\n\n\nNo-code: Work though on this website\nRunning .qmd files on Posit Cloud–.qmd files can be run similarly to rmarkdown files\n\nFollow these Instructions for getting started with this tutorial on POSIT cloud.",
    "crumbs": [
      "Home",
      "Module 1: Introduction"
    ]
  },
  {
    "objectID": "Module_1_Introduction.html#objectives",
    "href": "Module_1_Introduction.html#objectives",
    "title": "Module 1: Introduction",
    "section": "",
    "text": "In this workshop we will introduce and work with a Bayesian statistical modelling framework to:\n\nuse tree-ring data to estimate annual tree diameter growth with uncertainty\nintegrate tree-ring data with forest census data to estimate annual growth for all trees on the plot (i.e. those with and without tree ring data)\nshow how this approach can directly link annual growth to climate and other drivers, and\nscale annual growth to carbon accumulation. \n\nWe will work through examples developed in R and RStudio. Experience with R is helpful but not required. All are welcome.",
    "crumbs": [
      "Home",
      "Module 1: Introduction"
    ]
  },
  {
    "objectID": "Module_1_Introduction.html#motivation",
    "href": "Module_1_Introduction.html#motivation",
    "title": "Module 1: Introduction",
    "section": "",
    "text": "Managing forests to increase carbon uptake and storage is among the proposed carbon drawdown strategies. Tree-ring data makes it possible to quantify annual tree growth and carbon accumulation. While annually resolved, determining forest carbon accumulation from tree-rings requires complete sampling, or a set of assumptions that limit reliability. Tree-ring datasets are also subject to the fading record problem– they do not capture mortality processes.\nForest censuses, which re-measure individual trees over time, (e.g. Nationwide forest inventories (NFIs), ForestGEO plots, etc), provide snapshots of stand-level dynamics (forest growth, mortality, and recruitment processes) and thus forest carbon. This census data often lacks the annual temporal resolution needed to understand patterns and attribute forest carbon accumulation drivers. Participants of this workshop will learn how tree ring data alone, and tree ring data in combination with forest census data can be used to estimate forest carbon.\n\n\n\n\n\n\nEstimates of forest carbon and tree-level biomass over time are useful for a variety of applications, including: -understanding drivers of growth and mortality -quantifying the relative roles of growth, mortality, and regeneration in driving forest C over time",
    "crumbs": [
      "Home",
      "Module 1: Introduction"
    ]
  },
  {
    "objectID": "Module_1_Introduction.html#workshop-outline",
    "href": "Module_1_Introduction.html#workshop-outline",
    "title": "Module 1: Introduction",
    "section": "",
    "text": "We will work through a series of modules\n\nIntroduction & how to work through this tutorial (i.e. this page)\nIntroduction of Harvard Forest Census and Tree Ring Data\nEstimating Biomass from Ring width & Census data (no uncertainty)\nBayesian Growth Model Introduction\nRing-width only model\nCENSUS only model\nRing-width + CENSUS data\nComparing all three estimates",
    "crumbs": [
      "Home",
      "Module 1: Introduction"
    ]
  },
  {
    "objectID": "Module_1_Introduction.html#two-options-for-how-to-work-through-this-workshop",
    "href": "Module_1_Introduction.html#two-options-for-how-to-work-through-this-workshop",
    "title": "Module 1: Introduction",
    "section": "",
    "text": "No-code: Work though on this website\nRunning .qmd files on Posit Cloud–.qmd files can be run similarly to rmarkdown files\n\nFollow these Instructions for getting started with this tutorial on POSIT cloud.",
    "crumbs": [
      "Home",
      "Module 1: Introduction"
    ]
  },
  {
    "objectID": "Module_2_Data.html",
    "href": "Module_2_Data.html",
    "title": "Module 2: Data: Tree Ring and Census Data",
    "section": "",
    "text": "Code\npackages &lt;- c(\"ggplot2\", \"tidyverse\", \"rstan\", \"dplR\", \"reshape2\")\ninstall.packages(setdiff(packages, rownames(installed.packages())))  \n\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(rstan)\n\n\n\n\n\n\n\n\nNotes on running this tutorial\n\n\n\n\n\nBoxes like this one above contain R code to run this analysis. Clicking the arrow character in the upper right corner of the box will expand or collapse the contents of the box.",
    "crumbs": [
      "Home",
      "Module 2: Data: Tree Ring and Census Data"
    ]
  },
  {
    "objectID": "Module_2_Data.html#load-packages-to-be-used",
    "href": "Module_2_Data.html#load-packages-to-be-used",
    "title": "Module 2: Data: Tree Ring and Census Data",
    "section": "",
    "text": "Code\npackages &lt;- c(\"ggplot2\", \"tidyverse\", \"rstan\", \"dplR\", \"reshape2\")\ninstall.packages(setdiff(packages, rownames(installed.packages())))  \n\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(rstan)\n\n\n\n\n\n\n\n\nNotes on running this tutorial\n\n\n\n\n\nBoxes like this one above contain R code to run this analysis. Clicking the arrow character in the upper right corner of the box will expand or collapse the contents of the box.",
    "crumbs": [
      "Home",
      "Module 2: Data: Tree Ring and Census Data"
    ]
  },
  {
    "objectID": "Module_2_Data.html#tree-ring-data",
    "href": "Module_2_Data.html#tree-ring-data",
    "title": "Module 2: Data: Tree Ring and Census Data",
    "section": "Tree Ring Data",
    "text": "Tree Ring Data\n\nHarvard Forest tree ring data\nThere are two foundational datasets used in the processing of these biomass estimates. The first is a tree ring dataset collected by the Harvard Forest Research Area in 2012. Three 20m plots were measured following a double-nested design. The following species were included in the final ring width dataset:\n\nACRU = red maple (Acer rubrum)\nBEAL = yellow birch (Betula alleghaniensis)\nBELE = sweet birch (Betula lenta)\nFAGR = American beech (Fagus grandifolia)\nHAVI = Witch hazel (Hamamelis virginiana)\nPIST = Eastern white pine (Pinus strobus)\nQURU = Northern red oak (Quercus rubra)\nQUVE = Black oak (Quercus velutina)\nTSCA = Eastern hemlock (Tsuga canadensis)\n\nHarvard forest tree ring data samples were collected\nCitation on tree ring dataset: Dye, A. Barker Plotkin, D. Bishop, N. Pederson, B. Poulter, and A. Hessl. Comparing tree-ring and permanent plot estimates of aboveground net primary production in three eastern us forests. Ecosphere, 7(9), 2016.\n\nWe downloaded the raw data for Harvard Forest Tree ring data for you\nVisualize the pre-formatted HF tree ring data below\n\n\n\nCode\n# code to plot the tree ring data, by species\nHARV &lt;- readRDS(\"data/tree_data_HARVARD.RDS\")\ntaxon.conversion &lt;- readRDS(\"data/taxon_conversion.RDS\")\n\n# Xobs contains the increment data for all the cored trees\nhead(HARV$Xobs)\n\n\n      id year incr plot stat_id taxon\n1 LF1001   63 0.69    1       1  TSCA\n2 LF1001   64 0.95    1       1  TSCA\n3 LF1001   65 0.83    1       1  TSCA\n4 LF1001   66 0.57    1       1  TSCA\n5 LF1001   67 0.58    1       1  TSCA\n6 LF1001   68 0.79    1       1  TSCA\n\n\nCode\n# Tr contains the diameter at the closest measured year for each cored tree\nhead(HARV$Tr)\n\n\n  stat_id plot     id year  dbh distance taxon\n1       1    1 LF1001  114 18.1      7.6  TSCA\n2       2    1 LF1002  114 66.0      7.2  QURU\n3       3    1 LF1003  113 22.3      7.5  ACRU\n4       4    1 LF1004  113 30.4     10.6  ACRU\n5       5    1 LF1005  113 15.6      9.7  ACRU\n6       6    1 LF1007  113 30.0     11.9  BEAL\n\n\nCode\n# combine the tree ring data with their diameters\nTree.ring &lt;- HARV$Xobs %&gt;% left_join(., HARV$Tr)\n\n# get the calendar years\nyear.df &lt;- data.frame(year = max(Tree.ring$year):1, \n                      cal.year = 2012:(2013 - max(Tree.ring$year)))\nTree.ring &lt;- Tree.ring %&gt;% left_join(., year.df)\n\n# make a timeseries plot of all the tree ring increments\nggplot(data = Tree.ring)+geom_line(aes(x = cal.year, y = incr, group = id, color = taxon), alpha = 0.5)+facet_wrap(~taxon)+ylab(\"Increment (mm)\")+xlab(\"Year\")+theme_bw()\n\n\n\n\n\n\n\n\n\nCode\n# plot the diameter measurements for the cored trees\nggplot(data = Tree.ring)+geom_point(aes(x = cal.year, y = dbh, group = id, color = taxon), alpha = 0.5)+facet_wrap(~taxon)+ylab(\"Increment (mm)\")+xlab(\"Year\")+theme_bw()",
    "crumbs": [
      "Home",
      "Module 2: Data: Tree Ring and Census Data"
    ]
  },
  {
    "objectID": "Module_2_Data.html#harvard-forest-census-data",
    "href": "Module_2_Data.html#harvard-forest-census-data",
    "title": "Module 2: Data: Tree Ring and Census Data",
    "section": "Harvard Forest Census Data",
    "text": "Harvard Forest Census Data\nThe second dataset for this site includes the census data measured for the Lyford Plots, which is available on the Harvard Forest data archive website. Censuses were conducted in 1962, 1969, 1975, 1987-1991, 2001, and 2011 and mapped all trees with DBH greater than 5 cm. in a mapped area covering 2.88 ha. The three ring-width plots include only a fraction of this area, and, therefore, we determined which census trees were located within the plot areas and considered only those trees for the model.\n\n\nCode\n# code to plot census data, by species\n# - ACRU = red maple (Acer rubrum) \n# - BEAL = yellow birch (Betula alleghaniensis) \n# - BELE = sweet birch (Betula lenta)\n# - FAGR = American beech (Fagus grandifolia) \n# - HAVI = Witch hazel (Hamamelis virginiana) \n# - PIST = Eastern white pine (Pinus strobus)\n# - QURU = Northern red oak (Quercus rubra) \n# - QUVE = Black oak (Quercus velutina)\n# - TSCA = Eastern hemlock (Tsuga canadensis)\n\n\n# set up the lat-long information:\nHARV.ll &lt;- data.frame(site = c(\"LF1\", \"LF2\", \"LF3\"), \n                      lat = c(42.53065, 42.53128, 42.53008), \n                      lon = c(-72.18346, -72.18271, -72.18246))\n\nCensus &lt;- HARV$Dobs %&gt;% left_join(., year.df) %&gt;% \n  rename(\"taxon\" = \"species\")%&gt;%\n  left_join(., taxon.conversion) %&gt;%# combine with taxon-infomation\n  left_join(., HARV.ll) # combine with lat-long information\n\nggplot(data = Census)+geom_point(aes(x = cal.year, y = dbh, group = ID, color = `Scientific Name`, shape = finalCond), alpha = 0.5)+ geom_line(aes(x = cal.year, y = dbh, group = ID, color = `Scientific Name`)) + facet_wrap(~site, ncol = 3)+ylab(\"DBH (cm)\")+xlab(\"Year\")+theme_bw()",
    "crumbs": [
      "Home",
      "Module 2: Data: Tree Ring and Census Data"
    ]
  },
  {
    "objectID": "Module_2_Data.html#in-the-next-module",
    "href": "Module_2_Data.html#in-the-next-module",
    "title": "Module 2: Data: Tree Ring and Census Data",
    "section": "In the next module:",
    "text": "In the next module:\nWe will learn how to back-calculate tree diameters from tree ring data and how to scale tree diameter measurements up to tree-level biomass and carbon",
    "crumbs": [
      "Home",
      "Module 2: Data: Tree Ring and Census Data"
    ]
  },
  {
    "objectID": "Module_2_Data.html#additional-information",
    "href": "Module_2_Data.html#additional-information",
    "title": "Module 2: Data: Tree Ring and Census Data",
    "section": "Additional information:",
    "text": "Additional information:\nSome tree census data sources of regional interest include:\n- ForestGEO forest census plots (Cameroon, Congo, Gabon, Kenya, Nigeria) -",
    "crumbs": [
      "Home",
      "Module 2: Data: Tree Ring and Census Data"
    ]
  },
  {
    "objectID": "Module_6_Census_only.html#load-packages-to-be-used",
    "href": "Module_6_Census_only.html#load-packages-to-be-used",
    "title": "Module 6: Census only model",
    "section": "Load packages to be used",
    "text": "Load packages to be used\nWe estimate the parameters of this state-space model in a program called stan which interfaces to R via a package called rstan (cmdstan is another package that is used.)\n\n\nCode\nlibrary(rstan)\nlibrary(dplyr)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(gridExtra)\nlibrary(tidyr)",
    "crumbs": [
      "Home",
      "Module 6: Census only model"
    ]
  },
  {
    "objectID": "Module_6_Census_only.html#running-the-model-example-for-a-short-run",
    "href": "Module_6_Census_only.html#running-the-model-example-for-a-short-run",
    "title": "Module 6: Census only model",
    "section": "Running the model: Example for a short run",
    "text": "Running the model: Example for a short run\n\n\nCode\n# settings\niter = 500\nnchains = 1\n\ncompiled_CENSUS = stan_model(file = paste0('models/growth_model_CENSUS.stan'))\n\nfit_CENSUS = sampling(compiled_CENSUS, \n                      data = dat, \n                      iter = iter, \n                      chains = nchains,\n                      verbose=TRUE)",
    "crumbs": [
      "Home",
      "Module 6: Census only model"
    ]
  },
  {
    "objectID": "Module_6_Census_only.html#the-census-census-model-outputs",
    "href": "Module_6_Census_only.html#the-census-census-model-outputs",
    "title": "Module 6: Census only model",
    "section": "The CENSUS + CENSUS model outputs",
    "text": "The CENSUS + CENSUS model outputs\nWe will load the output from the fitted model (fitted model object and parameter posterior distributions).\n\n\nCode\nvariables = names(post_CENSUS[1,1,])\nallSX = grep('sig_x\\\\[',variables)\n\npost_sx = post_CENSUS[,,allSX]\n\ndim(post_sx)\n\n\n[1] 250   9\n\n\nCode\ncolnames(post_sx) = taxa\npost_sx_melt = melt(post_sx)\ncolnames(post_sx_melt) = c('iteration', 'species_code', 'sigma_x')\npost_sx_melt$model = 'CENSUS'\n\nsig_x_mean = post_sx_melt %&gt;% \n  group_by(species_code) %&gt;%\n  dplyr::summarize(sig_x_mean = mean(sigma_x))\nsig_x_mean = sig_x_mean[order(sig_x_mean$sig_x_mean),]\n\npost_sx_melt$species_code = factor(post_sx_melt$species_code, levels=sig_x_mean$species_code)\n\n# plot up the species level increment uncertainties\np = ggplot(data=post_sx_melt) +\n  # geom_boxplot(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  geom_violin(aes(x=species_code, y=sigma_x, colour=model, fill=model), alpha=0.5) +\n  theme_bw(14) +\n  xlab('Species') +\n  ylab('sigma_x')\nprint(p)",
    "crumbs": [
      "Home",
      "Module 6: Census only model"
    ]
  },
  {
    "objectID": "Module_6_Census_only.html#visualizing-chronology-like-effects-year-random-effects",
    "href": "Module_6_Census_only.html#visualizing-chronology-like-effects-year-random-effects",
    "title": "Module 6: Census only model",
    "section": "4. Visualizing chronology-like effects: year random effects",
    "text": "4. Visualizing chronology-like effects: year random effects\nHere we will also look at some summary figures for the beta_t parameter. For each species, there is a beta_t parameter for each year. This parameter is conceptually the same as a forest chronology; it is a time series that describes the common forest growth signal for a given species.\nWe could look at summary plots for the posterior samples for a given year for a given species, and do the same for all year BY species combinations. This would be (9 species) x (115 years) = 1035 trace plots, so we don’t look at all of them here.\nWe do want to visualize the beta_t chronology-like parameters as species-specific time series.\n\n\nCode\nallBTs = grep('beta_t\\\\[',variables)\npost_bt = post_CENSUS[,,allBTs]\n\npost_bt_melt = melt(post_bt)\npost_bt_melt$model = 'CENSUS-only'\n\nbt_pars_split = strsplit(as.vector(post_bt_melt$parameters), '\\\\[|\\\\,|\\\\]')\n\npost_bt_melt$species_code = taxa[sapply(bt_pars_split, function(x) as.numeric(x[[3]]))]\npost_bt_melt$year = years[sapply(bt_pars_split, function(x) as.numeric(x[[2]]))]\ncolnames(post_bt_melt) = c('iteration', 'parameter', 'beta_t', 'model', 'species_code', 'year')\n\nbeta_t_quant = post_bt_melt %&gt;% \n  group_by(model, species_code, year) %&gt;%\n  dplyr::summarize(beta_t_lo = quantile(beta_t, 0.025),\n                   beta_t_mid = quantile(beta_t, 0.5),\n                   beta_t_hi = quantile(beta_t, 0.975),\n                   beta_t_mean = mean(beta_t), \n                   .groups = 'keep')\n\np = ggplot(data=beta_t_quant) +\n  geom_hline(aes(yintercept=0), lty=2, lwd=1.2) +\n  geom_point(aes(x=year, y=beta_t_mid)) +\n  geom_linerange(aes(x=year, ymin=beta_t_lo, ymax=beta_t_hi)) +\n  xlab('year') +\n  ylab('beta_t') +\n  # xlim(c(year_lo, year_hi)) +\n  theme_bw(16) +\n  facet_grid(species_code~.)\nprint(p)\n\n\n\n\n\n\n\n\n\nHere we visualize inferred and observed diameter data for one tree (Tree 1). Filled circles indicate the diameter measurement included in this model and hollow circles are census diameter measurements not included in the model.\n\n\nCode\nallDs = grep('D\\\\[',variables)\npost_d = post_CENSUS[,,allDs]\n\ntree = 1\n\n\nprint(tree)\n\n\n[1] 1\n\n\nCode\nin.RW = tree %in% X2Tr\n\n# determine which estimates correspond to this tree\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\n# C\ndbh_iter_C = t(post_d[,inds_C])\ndbh_iter_C = data.frame(dbh_iter_C)\ndbh_iter_C = data.frame(year=years[yrinds_C], dbh_iter_C)\n\ndbh_mean_C = apply(dbh_iter_C[,2:ncol(dbh_iter_C)], 1, mean, na.rm=TRUE)\ndbh_quant_C = t(apply(dbh_iter_C[,2:ncol(dbh_iter_C)], 1, \n                      function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n\ndbh_tree_C = data.frame(d_mean = dbh_mean_C, \n                        d_median = dbh_quant_C[,2], \n                        d_lo = dbh_quant_C[,1], \n                        d_hi = dbh_quant_C[,3], \n                        year = years[yrinds_C],\n                        model = 'Census')\n\n\n\ndbh_tree = dbh_tree_C\n\nidx_d_obs_C = which(Dobs$stat_id == tree)\n\ndbh_obs_C = data.frame(d_obs = Dobs$dbh[idx_d_obs_C],\n                       year = years[Dobs$year[idx_d_obs_C]])\n\nstem_id = Dobs$ID[idx_d_obs_C][1]\n\nif (in.RW){\n  idx_d_obs = which(Tr$stat_id == tree)\n  \n  dbh_obs = data.frame(d_obs = Tr$dbh[idx_d_obs],\n                       year = years[Tr$year[idx_d_obs]])\n  \n} else {\n  dbh_obs = data.frame(d_obs = numeric(0),\n                       year = numeric(0))\n}\n\n# Create a text\ngrob = grobTree(textGrob(paste0('Tree ', tree, '; ID ', stem_id, '; Species ', taxon_C[tree] ), x=0.05,  y=0.9, hjust=0,\n                         gp=gpar(col=\"black\", fontsize=18)))\n\np1 = ggplot() +\n  geom_ribbon(data=dbh_tree, aes(x=year, ymin=d_lo, ymax=d_hi, fill=model), alpha=0.5) +\n  geom_line(data=dbh_tree, aes(x=year, y=d_median, colour=model)) +\n  # geom_point(data=dbh_obs, aes(x=year, y=d_obs), size=2) +\n  geom_point(data=dbh_obs_C, aes(x=year, y=d_obs), size=2, shape=1) +\n  xlab('year') +\n  ylab('dbh (cm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)  +\n  annotation_custom(grob)\n\nprint(p1)\n\n\n\n\n\n\n\n\n\n\n\nCode\nallRWs = grep('X\\\\[',variables)\npost_rw = post_CENSUS[,,allRWs]\n\ninds_C = which(X2Tr_C == tree)\nyrinds_C = X2year_C[inds_C]\n\nrw_iter_C = t(post_rw[,inds_C])\nrw_iter_C = data.frame(rw_iter_C)\nrw_iter_C = data.frame(year=years[yrinds_C], rw_iter_C)\n\nrw_mean_C = apply(rw_iter_C[,2:ncol(rw_iter_C)], 1, mean, na.rm=TRUE)\nrw_quant_C = t(apply(rw_iter_C[,2:ncol(rw_iter_C)], 1, \n                     function(x) quantile(x, c(0.025, 0.5, 0.975), na.rm=TRUE)))\n\nrw_tree_C = data.frame(x_mean = rw_mean_C, \n                       x_median = rw_quant_C[,2], \n                       x_lo = rw_quant_C[,1], \n                       x_hi = rw_quant_C[,3], \n                       year = years[yrinds_C],\n                       model = 'Census')\n\nrw_tree = rw_tree_C\n\n\nrw_obs = data.frame(x_obs = numeric(0),\n                    year = numeric(0))\n\np2 = ggplot() +\n  geom_ribbon(data=rw_tree, aes(x=year, ymin=x_lo, ymax=x_hi, fill=model), alpha=0.5) +\n  geom_line(data=rw_tree, aes(x=year, y=x_median, colour=model)) +\n  geom_point(data=rw_obs, aes(x=year, y=x_obs), size=2, alpha=0.4) +\n  xlab('year') +\n  ylab('rw (mm)') +\n  xlim(c(year_lo, year_hi)) +\n  theme_bw(16)\n\ngrid.arrange(p1, p2, nrow = 2)",
    "crumbs": [
      "Home",
      "Module 6: Census only model"
    ]
  },
  {
    "objectID": "Module_6_Census_only.html#plot-of-agb-and-agbi-with-uncertainty",
    "href": "Module_6_Census_only.html#plot-of-agb-and-agbi-with-uncertainty",
    "title": "Module 6: Census only model",
    "section": "Plot of AGB and AGBI with uncertainty",
    "text": "Plot of AGB and AGBI with uncertainty\n\n\nCode\n# melt down agb_array to data frame\nagb_melt = melt(agb_array_CENSUS)\ncolnames(agb_melt) = c('tree','year','iter','value')\nagb_melt = agb_melt %&gt;% filter(!is.na(value))\nagb_melt$year = years[agb_melt$year]\nagb_melt$plot = plot_C[agb_melt$tree]\nagb_melt$taxon = taxon_C[agb_melt$tree]\nagb_melt$model = rep(\"CENSUS-only\", nrow(agb_melt))\nagb_melt$type = rep('ab',nrow(agb_melt))\n\n# first for CENSUS only model\nabi = apply(agb_array_CENSUS, c(1,3), function(x) diff(x))\nabi = aperm(abi, c(2, 1, 3))\nabi_melt = melt(abi)\ncolnames(abi_melt) = c('tree', 'year', 'iter', 'value')\nabi_melt = abi_melt %&gt;% filter(!is.na(value))\nabi_melt$year = years[abi_melt$year]\nabi_melt$plot = plot_C[abi_melt$tree]\nabi_melt$taxon = taxon_C[abi_melt$tree]\nabi_melt$model = rep(\"CENSUS-only\", nrow(abi_melt))\nabi_melt$type = rep('abi',nrow(abi_melt))",
    "crumbs": [
      "Home",
      "Module 6: Census only model"
    ]
  },
  {
    "objectID": "Module_6_Census_only.html#taxon-level-aboveground-biomass-agb-and-aboveground-biomass-increment-agbi",
    "href": "Module_6_Census_only.html#taxon-level-aboveground-biomass-agb-and-aboveground-biomass-increment-agbi",
    "title": "Module 6: Census only model",
    "section": "Taxon-level Aboveground Biomass (AGB) and Aboveground Biomass Increment (AGBI)",
    "text": "Taxon-level Aboveground Biomass (AGB) and Aboveground Biomass Increment (AGBI)\n\n\nCode\nagb_taxon_by_iter = agb_melt %&gt;%\n  group_by(year, iter, taxon, plot, model) %&gt;% \n  # # sum up the taxon-level information by plot, iteration, year\n  summarise( AGB.taxon.plot = sum(value, na.rm =TRUE)) %&gt;% ungroup() %&gt;%\n  # \n  # get the mean value across plots for each iteration:\n  group_by(year, iter, taxon, model) %&gt;%\n  # dplyr::summarize(AGB.iter.mean = mean(value, na.rm = TRUE),\n  #                  .groups='keep')\n  dplyr::summarize(AGB.iter.mean = mean(AGB.taxon.plot, na.rm = TRUE),\n                   .groups='keep')\n\n\n`summarise()` has grouped output by 'year', 'iter', 'taxon', 'plot'. You can\noverride using the `.groups` argument.\n\n\nCode\nagb_taxon_summary = agb_taxon_by_iter %&gt;%ungroup() %&gt;% \n  group_by(year, taxon, model) %&gt;% \n  dplyr::summarize(AGB.mean = mean(AGB.iter.mean, na.rm = TRUE),\n                   AGB.sd = sd(AGB.iter.mean, na.rm=TRUE),\n                   AGB.lo = quantile(AGB.iter.mean, c(0.025), na.rm=TRUE),\n                   AGB.hi = quantile(AGB.iter.mean, c(0.975), na.rm=TRUE), \n                   .groups='keep')\n\nabi_taxon_by_iter = abi_melt %&gt;%\n  group_by(year, iter, taxon, plot, model) %&gt;% \n  summarise( AGBI.taxon.plot = sum(value, na.rm =TRUE)) %&gt;% ungroup() %&gt;%\n  group_by(year, iter, taxon, model) %&gt;% \n  dplyr::summarize(ABI.iter.mean = mean(AGBI.taxon.plot, na.rm = TRUE),\n                   .groups='keep')\n\n\n`summarise()` has grouped output by 'year', 'iter', 'taxon', 'plot'. You can\noverride using the `.groups` argument.\n\n\nCode\n#taxon summary data without plot \nabi_taxon_summary = abi_taxon_by_iter %&gt;% ungroup() %&gt;%\n  group_by(year, taxon, model) %&gt;% \n  dplyr::summarize(ABI.mean = mean(ABI.iter.mean, na.rm = TRUE),\n                   ABI.sd = sd(ABI.iter.mean, na.rm=TRUE),\n                   ABI.lo = quantile(ABI.iter.mean, c(0.025), na.rm=TRUE),\n                   ABI.hi = quantile(ABI.iter.mean, c(0.975), na.rm=TRUE), \n                   .groups='keep')\n\n\n\n\nCode\nggplot(data = agb_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=AGB.lo, ymax=AGB.hi, colour=taxon, fill=taxon), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = AGB.mean, color = taxon))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_taxon_summary)+\n  geom_ribbon(aes(x=year, ymin=ABI.lo, ymax=ABI.hi, colour=taxon, fill=taxon), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = ABI.mean, color = taxon))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass increment (mg/ha)')",
    "crumbs": [
      "Home",
      "Module 6: Census only model"
    ]
  },
  {
    "objectID": "Module_6_Census_only.html#stand-level-biomass-and-biomass-increment",
    "href": "Module_6_Census_only.html#stand-level-biomass-and-biomass-increment",
    "title": "Module 6: Census only model",
    "section": "Stand-level Biomass and Biomass increment",
    "text": "Stand-level Biomass and Biomass increment\n\n\nCode\nagb_all_plot_by_iter &lt;- agb_melt |&gt;\n  group_by(year, iter, plot, model) |&gt;\n  # sums all of the trees by plot\n  dplyr::summarize(AGB.sum = sum(value),\n                   .groups = 'keep') \n\nagb_site_by_iter &lt;- agb_all_plot_by_iter |&gt;\n  group_by(year, iter, model) |&gt;\n  dplyr::summarize(AGB.iter = mean(AGB.sum),\n                   .groups = 'keep') \n\nagb_site_summary = agb_site_by_iter %&gt;%\n  group_by(year, model) %&gt;%\n  dplyr::summarize(abmean = mean(AGB.iter, na.rm=T),\n                   ab025 = quantile(AGB.iter, 0.025),\n                   ab50 = quantile(AGB.iter, 0.5),\n                   ab975 = quantile(AGB.iter, 0.975), \n                   .groups = 'keep') %&gt;% \n  ungroup()\n\n\n\nabi_all_plot_by_iter &lt;- abi_melt |&gt;\n  group_by(year, iter, plot, model) |&gt;\n  dplyr::summarize(ABI.sum = sum(value),\n                   .groups = 'keep') \n\nabi_site_by_iter &lt;- abi_all_plot_by_iter |&gt;\n  group_by(year, iter, model) |&gt;\n  dplyr::summarize(ABI.iter = mean(ABI.sum),\n                   .groups = 'keep') \n\nabi_site_summary = abi_site_by_iter %&gt;%\n  group_by(year, model) %&gt;%\n  dplyr::summarize(abimean = mean(ABI.iter, na.rm=T),\n                   abi025 = quantile(ABI.iter, 0.025),\n                   abi50 = quantile(ABI.iter, 0.5),\n                   abi975 = quantile(ABI.iter, 0.975), \n                   .groups = 'keep') %&gt;% \n  ungroup()\n\nsaveRDS(abi_site_summary, \"summary/abi_site_summary_CENSUS.RDS\")\nsaveRDS(agb_site_summary, \"summary/agb_site_summary_CENSUS.RDS\")\n\nsaveRDS(abi_taxon_summary, \"summary/abi_taxon_summary_CENSUS.RDS\")\nsaveRDS(agb_taxon_summary, \"summary/agb_taxon_summary_CENSUS.RDS\")\n\n\n\n\nCode\nggplot(data = agb_site_summary)+\n  geom_ribbon(aes(x=year, ymin=ab025, ymax=ab975), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abmean))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = abi_site_summary)+\n  geom_ribbon(aes(x=year, ymin=abi025, ymax=abi975), alpha=0.4, linetype=2) +\n  geom_line(aes(x = year, y = abimean))+\n  facet_grid(model~., scales='free_y') +\n  theme_light(18) +\n  ylab('biomass (mg/ha)')",
    "crumbs": [
      "Home",
      "Module 6: Census only model"
    ]
  },
  {
    "objectID": "Module_3_Biomass_estimation.html",
    "href": "Module_3_Biomass_estimation.html",
    "title": "Module 3: Estimating Biomass From Tree Ring Data",
    "section": "",
    "text": "How do we get estimates of aboveground biomass and forest carbon from tree diameters and tree ring data?\nAllometric equations define the relationship between commonly measured aspects of a tree (usually tree species, diameter, and/or height) and the weight of the tree (aboveground biomass, AGB). These equations are developed through a small set of destructive samples– this involves sampling tree size, height, and species, measuring tree mass, and developing a quantitative relationship between the commonly measured metric and tree mass.\nIn this module we will:\n\nApply species-specific allometric equations to the Harvard Forest Census dataset to estimate AGB at the time of census\nBack-calculate tree diameter from the tree ring data at Harvard Forest\nApply allometric equations to the back-calculated tree diameters at Harvard Forest to estimate a timeseries of AGB.\n\n\n\n\n\nThis package is available on github, and we highlight some additional resources here:\n\nCitation: Gonzalez-Akre, E.,  Piponiot, C.,  Lepore, M.,  Herrmann, V.,  Lutz, J. A.,  Baltzer, J. L.,  Dick, C. W.,  Gilbert, G. S., He, F.,  Heym, M.,  Huerta, A. I.,  Jansen, P. A.,  Johnson, D. J.,  Knapp, N.,  Král, K.,  Lin, D.,  Malhi, Y.,  McMahon, S. M.,  Myers, J. A., …  Anderson-Teixeira, K. J. (2022).  allodb: An R package for biomass estimation at globally distributed extratropical forest plots. Methods in Ecology and Evolution,  13,  330–338. https://doi.org/10.1111/2041-210X.13756\nGithub repository: https://github.com/ropensci/allodb/tree/master\nTutorial at Ropensci: https://docs.ropensci.org/allodb/\n\n\n\nCode\ndevtools::install_github(\"ropensci/allodb\",upgrade = \"never\")\nlibrary(allodb)\nlibrary(tidyverse)\nlibrary(dplR)\nlibrary(gt)\nlibrary(reshape2)\n\nHARV &lt;- readRDS(\"data/tree_data_HARVARD_STAN_v3.1_102020.RDS\")\n\n\ntaxon.conversion &lt;- readRDS(\"data/taxon_conversion.RDS\")\n\nTree.ring &lt;- HARV$Xobs %&gt;% left_join(., HARV$Tr)\n\n# get the calendar years\nyear.df &lt;- data.frame(year = max(Tree.ring$year):1, \n                      cal.year = 2012:(2013 - max(Tree.ring$year)))\n\nTree.ring &lt;- Tree.ring %&gt;% left_join(., year.df)\n\nyear.df &lt;- data.frame(year = max(Tree.ring$year):1, \n                      cal.year = 2012:(2013 - max(Tree.ring$year)))\n# set up the lat-long information:\nHARV.ll &lt;- data.frame(site = c(\"LF1\", \"LF2\", \"LF3\"), \n                      lat = c(42.53065, 42.53128, 42.53008), \n                      lon = c(-72.18346, -72.18271, -72.18246))\n\nCensus &lt;- HARV$Dobs %&gt;% left_join(., year.df) %&gt;% \n  rename(\"taxon\" = \"species\")%&gt;%\n  left_join(., taxon.conversion) %&gt;%# combine with taxon-infomation\n  left_join(., HARV.ll) # combine with lat-long information\n\nCensus &lt;- Census %&gt;% \n  mutate(INV.YEAR = ifelse(cal.year &gt;= 1985 & cal.year &lt;= 1991, 1990, cal.year))\n\n\nHere, we will focus on species from Harvard Forest, so lets see which species we have in our census data. This information is stored in the taxon column in the Census object:\n\n\nCode\n# lets visualize the number of trees sampled at Harvard Forest each census year:\nCensus %&gt;% group_by(taxon, `Scientific Name`, COMMON_NAME, INV.YEAR) %&gt;%\n  summarise(n.trees = n()) %&gt;% \n  group_by(taxon, `Scientific Name`, COMMON_NAME) %&gt;% \n  spread(INV.YEAR, n.trees, fill = 0) %&gt;%\n  ungroup() %&gt;% gt()\n\n\n\n\n\n\n\n\ntaxon\nScientific Name\nCOMMON_NAME\n1960\n1967\n1973\n1990\n1999\n2009\n\n\n\n\nACRU\nAcer rubrum\nred maple\n41\n211\n188\n141\n111\n90\n\n\nBEAL\nBetula alleghaniensis\nyellow birch\n8\n17\n18\n16\n24\n29\n\n\nBELE\nBetula lenta\nsweet birch\n2\n5\n5\n7\n10\n16\n\n\nFAGR\nFagus grandifolia\nAmerican beech\n2\n4\n4\n12\n16\n26\n\n\nHAVI\nHamamelis virginiana\nAmerican witchhazel\n2\n5\n5\n9\n10\n25\n\n\nPIST\nPinus strobus\neastern white pine\n4\n29\n24\n6\n8\n8\n\n\nQURU\nQuercus rubra\nnorthern red oak\n27\n129\n114\n79\n73\n67\n\n\nQUVE\nQuercus velutina\nblack oak\n1\n7\n6\n4\n3\n3\n\n\nTSCA\nTsuga canadensis\neastern hemlock\n3\n4\n7\n8\n13\n25\n\n\n\n\n\n\n\nCode\n# we can also plot this up visually:\n\nggplot(data = Census)+\ngeom_bar(aes(x = as.character(INV.YEAR), fill = `Scientific Name`), position = \"dodge\")+theme_bw()+\nylab(\"Number of Trees Observed\")+\nxlab(\"Inventory Year\")+facet_wrap(~site, ncol = 1)\n\n\n\n\n\n\n\n\n\nBased on this table and figure, which species do you think will have the largest aboveground biomass?\n\n\n\nThis function requires the following arguments and provides and output of Aboveground biomass in kilograms (kg):\n\ndbh: diameter at breast height (cm), numeric\ngenus: genus of the tree, character\nspecies: the species name of the tree, character, can be NULL if only genus is known\ncoords: a vector (longitude, latitude) of the plot location, or a matrix with 2 columns if trees have individual locations\n\n\n\nCode\nrequire(allodb)\n\n# lets get the biomass for the first tree in the Census data (a 36.83 cm Northern Red Oak (Quercus rubra):\n\nCensus.1 &lt;- Census[1,] # first tree\n\nCensus.1$AGB.1 &lt;-\n  get_biomass(\n    dbh = Census.1$dbh ,\n    genus = Census.1$GENUS,\n    species = Census.1$SPECIES,\n    coords = c(Census.1$lon, Census.1$lat)\n  )\n\nCensus.1$AGB\n\n\n[1] 979.5547\n\n\nNow lets apply this function to the whole dataset\n\n\nCode\nll &lt;- matrix(c(Census$lon, Census$lat), nrow = length(Census$lon), ncol = 2, byrow = FALSE, dimnames = NULL)\n\n# here we split up the census by sites \nCensus.LF1 &lt;- Census %&gt;% filter(site %in% \"LF1\")\nLF1.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF1\")\n\nCensus.LF2 &lt;- Census %&gt;% filter(site %in% \"LF2\")\nLF2.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF2\")\n\nCensus.LF3 &lt;- Census %&gt;% filter(site %in% \"LF3\")\nLF3.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF3\")\n\n# get the biomass for each site:\nCensus.LF1$AGB_kg &lt;-\n  get_biomass(\n    dbh = Census.LF1$dbh ,\n    genus = Census.LF1$GENUS,\n    species = Census.LF1$SPECIES,\n    coords = c(LF1.ll$lon, LF1.ll$lat))\n\n\nCensus.LF2$AGB_kg &lt;-\n  get_biomass(\n    dbh = Census.LF2$dbh ,\n    genus = Census.LF2$GENUS,\n    species = Census.LF2$SPECIES,\n    coords = c(LF2.ll$lon, LF2.ll$lat))\n\nCensus.LF3$AGB_kg &lt;-\n  get_biomass(\n    dbh = Census.LF3$dbh ,\n    genus = Census.LF3$GENUS,\n    species = Census.LF3$SPECIES,\n    coords = c(LF3.ll$lon, LF3.ll$lat))\n\nplot_radius = 20\n\n\nCensus.AGB &lt;- rbind(Census.LF1, Census.LF2, Census.LF3) %&gt;% \n  mutate(tph_corr = (1/(pi*plot_radius^2)) * (1/0.0001) * (1/1000)) #%&gt;%  # get tree per hectare correction factor to scale tree biomass up\n  #mutate(AGB_Mg_ha = AGB_kg*) # convert the tree level AGB to MG/ha)\n\n\n\nggplot(data = Census.AGB)+\n  geom_point(aes(x = INV.YEAR, y = AGB_kg, group = ID, color = `Scientific Name`))+\n  geom_line(aes(x = INV.YEAR, y = AGB_kg, group = ID, color = `Scientific Name`))+\n  facet_wrap(~site)+theme_bw()+ylab(\"Tree Aboveground Biomass (kg)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\n\nWhich species are increasing the most over time? Is this what you expected based on the number of trees tallied? Here, we have added lines to visualize the trajectory of taxon AGB over time, but we don’t have estimates of variability in annual AGB increment over time.\n\n\nCode\n# ggplot(data = Census.AGB)+\n#   geom_point(aes(x = INV.YEAR, y =AGB_Mg_ha, group = ID, color = `Scientific Name`))+\n#   geom_line(aes(x = INV.YEAR, y = AGB_Mg_ha, group = ID, color = `Scientific Name`))+\n#   facet_wrap(~site)+theme_bw()+ylab(\"Tree Aboveground Biomass (Mg/ha)\")+xlab(\"Year\")\n\nCensus.AGB.sums &lt;- Census.AGB %&gt;% group_by(taxon, `Scientific Name`, site, INV.YEAR) %&gt;% \n  summarise(AGB_Mg_ha_taxon = sum(AGB_kg*tph_corr, na.rm =TRUE))\n\nggplot(data = Census.AGB.sums)+\n  geom_point(aes(x = INV.YEAR, y = AGB_Mg_ha_taxon, color = `Scientific Name`))+\n  geom_line(aes(x = INV.YEAR, y = AGB_Mg_ha_taxon, color = `Scientific Name`))+\n  facet_wrap(~site)+theme_bw()+ylab(\"Taxon Aboveground Biomass (Mg/ha)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\n\nForest demographic processes affecting AGB:\n\nRecruitment of new small trees into the plot\nMortality of trees (or conversely, survival)\nGrowth of existing trees in the plot\n\nCensus data provide an estimate of these processes over the remeasurement period.\nRecruitment makes up a small amount of AGB at these plots:\n\n\n  site     ID taxon variable    value recruit.code   Recruitment\n1  LF1 LF1001  TSCA     1960       NA            0 Existing Tree\n2  LF1 LF1001  TSCA     1967       NA            0 Existing Tree\n3  LF1 LF1001  TSCA     1973       NA            0 Existing Tree\n4  LF1 LF1001  TSCA     1990 19.36831            1   New Recruit\n5  LF1 LF1001  TSCA     1999 45.02890            0 Existing Tree\n6  LF1 LF1001  TSCA     2009 99.23069            0 Existing Tree\n\n\n\n\n\n\n\n\n\nThere are some mortality events that remove AGB\n\n\n\n\n\n\n\n\n\nTree and taxon average annual growth and average annual aboveground biomass increment (AGBI) appear to vary across remeasurement periods:\n\n\nCode\n# Growth\nAverage.Growth.census &lt;- mortality.code.census %&gt;% \n  group_by(site, ID) %&gt;%\n  arrange(cal.year) %&gt;% \n  mutate(REMPER = cal.year - lag(cal.year),\n         prevDBH = lag(dbh), \n         prevAGB = lag(AGB_kg)) %&gt;% \n  # if the tree died in the remeasurement period, assume it died halfway through \n  mutate(REMPER.mort.corrected = ifelse(mort.code == 1, REMPER/2, REMPER)) %&gt;%\n  ungroup() %&gt;%\n  mutate(tree.AGBI = (AGB_kg - prevAGB)/REMPER.mort.corrected, \n         tree.growth = (dbh - prevDBH)/REMPER.mort.corrected) \n\n\nggplot(data = Average.Growth.census) + \n  geom_point(aes(x = INV.YEAR, y = tree.AGBI, color = taxon, group = ID))+\n  geom_line(aes(x = INV.YEAR, y = tree.AGBI, color = taxon, group = ID))+ facet_wrap(~site)+ylab(\"Tree Average Aboveground Biomass Increment (kg/year)\")\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = Average.Growth.census) + \n  geom_point(aes(x = INV.YEAR, y = tree.growth, color = taxon, group = ID))+\n  geom_line(aes(x = INV.YEAR, y = tree.growth, color = taxon, group = ID))+ facet_wrap(~site)+ylab(\"Tree Average Growth Increment (cm/year)\")+xlab(\"Inventory Year\")\n\n\n\n\n\n\n\n\n\nCode\nsite.avgs &lt;- Average.Growth.census %&gt;% group_by(site, taxon, INV.YEAR)%&gt;%\n  summarise(taxon.AGBI.avg = mean(tree.AGBI, na.rm =TRUE), \n            taxon.DI.avg = mean(tree.AGBI, na.rm =TRUE))\nggplot(data = site.avgs) + \n  geom_point(aes(x = INV.YEAR, y = taxon.DI.avg, color = taxon))+\n  geom_line(aes(x = INV.YEAR, y = taxon.DI.avg, color = taxon))+ facet_wrap(~site)+ylab(\"Taxon Average Growth Increment (cm/year)\")+xlab(\"Inventory Year\")\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = site.avgs) + \n  geom_point(aes(x = INV.YEAR, y = taxon.AGBI.avg, color = taxon))+\n  geom_line(aes(x = INV.YEAR, y = taxon.AGBI.avg, color = taxon))+ facet_wrap(~site)+ylab(\"Taxon Average AGBI (kgyear)\")+xlab(\"Inventory Year\")\n\n\n\n\n\n\n\n\n\nHowever, some remeasurement periods are quite long, and we miss inter-annual variation that could lead to differences in estimates of annual AGBI. Tree-ring data can help us fill in these gaps in our understanding of how AGB varies over time, since they are a direct measurement of annual growth.\n\n\n\n\nIn order to use tree ring data to estimate tree AGB, we first need to convert measurements of annual tree growth into estimates of tree diameter.\nThere are many different ways to convert tree ring radial increments to an estimate of circumference (i.e. diameter) and to an estimate of area (i.e. basal area). The dplR package from opendendro has some functions to calculate basal area increment–check out bai.in, bai.out, and bakker.\nFor simplicity here, we will we assume that each tree grows symmetrically and in a circle. So we convert tree ring growth data for each core from radial increment to a diameter increment by multiplying by 2. Because we have a diameter measurement from a recent census, we can back-calculate the diameter by subtracting the following year’s increment. To calculate the Diameter for core () in the year just before the census diameter was taken year (), we subtract the diameter increment growth () from the Census measured Diameter \n\n\nRead in the rwl files for red maple at Harvard Forest (using read.tucson function in dplR) and link them up to the census dataset.\n\n\nCode\nlibrary(dplR)\n# read in the rwl files using the helpful dplR functions:\nall.HF.rwl &lt;- list.files(\"data/rwl/\", pattern = \".rwl\", full.names = T)\n\n\nread.rwl.reformat &lt;- function(SPCD.rwl){\n        inc.rwl &lt;- read.tucson(SPCD.rwl)\n        # here, I reformat the data as a dataframe, get a tree id (id), and keep a core.id.\n        # the core.id is a separate core that denotes what direction on the tree the sample was taken from\n        inc.rwl.df &lt;- data.frame(inc.rwl) %&gt;% mutate(cal.year = row.names(inc.rwl)) %&gt;%\n          reshape2::melt(., id.vars = \"cal.year\") %&gt;% \n          rename(\"core.id\" = \"variable\", \n                 \"incr\" = \"value\") %&gt;%\n          mutate(id = substr(core.id, 1, 6)) %&gt;% \n          filter(!is.na(incr))%&gt;%\n          mutate(cal.year = as.numeric(cal.year))\n        \n        return(inc.rwl.df)\n\n}\n\nall.HF.increment &lt;- do.call(rbind, lapply(all.HF.rwl, read.rwl.reformat))\n# get the diameter measurements for the cored trees:\nCored.Diam &lt;- HARV$Tr %&gt;% left_join(., year.df) %&gt;%\n  left_join(., all.HF.increment ) %&gt;% filter(!is.na(core.id)) %&gt;% select(-incr)%&gt;%\n  rename(\"cored.year\"=\"year\", \n         \"cored.cal.year\"= \"cal.year\")\n\ninc.diam &lt;- all.HF.increment  %&gt;% left_join(., Cored.Diam)\n\n# example of back-calculating diameters for all the red maple cores\ncore.all &lt;- inc.diam %&gt;% \n  \n  # filter so we only have increments from the last census diameter measurement or earlier (for now)\n  filter(cal.year &lt;= cored.cal.year) %&gt;% \n  \n  # get the cumulative diameter increment, or how much the tree has grown from the outside in since a given year:\n  # The increments are in mm, so convert to cm by dividing by 10\n  # assume the tree is a perfect circle so multiply by 2 to get the diameter increment\n\n  #filter(id %in% \"LF1035\") %&gt;% \n  group_by(core.id) %&gt;% \n  arrange(desc(cal.year)) %&gt;% \n  \n  # calculate the cumulative sum of diameter increments, from the cored diameter to the earliest:\n  mutate(cum.diainc = cumsum((incr/10)*2), \n         dia.inc = (incr/10)*2) %&gt;% \n  # simplify this dataset for use:\n  select(cal.year, cored.cal.year, core.id, incr, id, dbh, cum.diainc, dia.inc, plot) %&gt;%\n  ungroup()%&gt;%\n  \n  # grouping by the core id after arranging by calendar year is important!!\n  group_by(core.id) %&gt;%\n  # if the year is the year the cored tree diameter was measured, use that as the dbh\n  mutate(dbh_cm_bc = ifelse(cal.year == cored.cal.year, dbh, \n  # if the year is before the tree was cored, use lag to subtract the cumulative increment\n  # lag gives use the previous value (gives the cumulative diameter increment from year == 2012 for cal.year == 2011)\n                            ifelse(cal.year &lt; cored.cal.year, dbh - lag(cum.diainc), NA)))\n  \n  # to convince yourself that this is working right, check that the estimated increments == the tree diameter increment:\n  # core.all %&gt;% mutate(check.dia.inc = dbh_cm_bc - lead(dbh_cm_bc)) %&gt;% \n  #   filter(!round(dia.inc, 3) == round(check.dia.inc, 3) )\n\n\n\n\nCode\neast.core &lt;- core.all %&gt;% filter(core.id %in% \"LF1005e\")\n ggplot()+geom_line(data = east.core, aes(x = cal.year, y = dbh_cm_bc, color = core.id))+\n   geom_point(data = east.core %&gt;% filter(cal.year == cored.cal.year), aes(x = cal.year, y = dbh))+ylab(\"Tree diameter (cm)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\n\nUsing our simple method get a back-calculated tree diameter estimate based on each core. When using tree-ring data to estimate trends in tree size (or Basal Area, Aboveground Biomass, etc), the variation in tree ring widths from different cores in the same tree and year represents observation uncertainty. Here, a single red maple tree (LF1005) has three cores, with variability in tree ring increment and the back-calculated tree size.\n\n\nCode\nLF2012 &lt;- core.all %&gt;% filter(id %in% \"LF1005\")\n\n DBH.bc.p &lt;- ggplot()+geom_line(data = LF2012, aes(x = cal.year, y = dbh_cm_bc, color = core.id))+\n   geom_point(data = LF2012 %&gt;% filter(cal.year == cored.cal.year), aes(x = cal.year, y = dbh))+ylab(\"Tree diameter (cm)\")+xlab(\"Year\")\n \n inc.p &lt;-  ggplot()+geom_line(data = LF2012, aes(x = cal.year, y = dia.inc, color = core.id))+\n   ylab(\"Tree Diameter Increment (cm)\")+xlab(\"Year\")\n \n cowplot::plot_grid(inc.p, DBH.bc.p, ncol = 1)\n\n\n\n\n\n\n\n\n\nWe note that the approach in this module has some issues, including the possibility of estimating negative tree diameters near the beginning of the time series, ignoring bark thickness, and assuming perfectly circular tree trunks.\nLater in our tutorial, we will demonstrate how developing a “data model” can allow us to estimate uncertainty due to information from different cores and to include this uncertainty in our estimates of tree diameter and aboveground biomass. For this module, we will average the diameter increments for each core before back-calculating the diameters to demonstrate how to estimate biomass over time.\n\n\n\n\n\nCode\ntree.averages &lt;- inc.diam %&gt;% \n  group_by(id, cal.year, dbh, cored.cal.year, taxon, plot) %&gt;%\n  summarise(incr.avg = mean(incr, na.rm = TRUE)) %&gt;% \n  \n  # filter so we only have increments from the last census diameter measurement or earlier (for now)\n  filter(cal.year &lt;= cored.cal.year) %&gt;% \n  \n  # get the cumulative diameter increment, or how much the tree has grown from the outside in since a given year:\n  # The increments are in mm, so convert to cm by dividing by 10\n  # assume the tree is a perfect circle so multiply by 2 to get the diameter increment\n  group_by(id) %&gt;% \n  arrange(desc(cal.year)) %&gt;% \n  \n  # calculate the cumulative sum of diameter increments, from the cored diameter to the earliest:\n  mutate(cum.diainc = cumsum((incr.avg/10)*2), \n         dia.inc = (incr.avg/10)*2) %&gt;% \n  # simplify this dataset for use:\n  select(cal.year, cored.cal.year, incr.avg, id, dbh, cum.diainc, dia.inc, plot, taxon) %&gt;%\n  ungroup()%&gt;%\n  \n  # grouping by the core id after arranging by calendar year is important!!\n  group_by(id) %&gt;%\n  # if the year is the year the cored tree diameter was measured, use that as the dbh\n  mutate(dbh_cm_bc = ifelse(cal.year == cored.cal.year, dbh, \n  # if the year is before the tree was cored, use lag to subtract the cumulative increment\n  # lag gives use the previous value (gives the cumulative diameter increment from year == 2012 for cal.year == 2011)\n                            ifelse(cal.year &lt; cored.cal.year, dbh - lag(cum.diainc), NA)))\n\n\n`summarise()` has grouped output by 'id', 'cal.year', 'dbh', 'cored.cal.year',\n'taxon'. You can override using the `.groups` argument.\n\n\nCode\n ggplot()+geom_line(data = tree.averages, aes(x = cal.year, y = dbh_cm_bc, group = id, color = taxon))+\n   geom_point(data = tree.averages %&gt;% filter(cal.year == cored.cal.year), aes(x = cal.year, y = dbh))+ylab(\"Tree diameter (cm)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe convert back-calculated tree diameters to aboveground biomass, again using the allometric equations in the allodb package.\n\n\nCode\ntree.averages &lt;- tree.averages %&gt;% left_join(.,taxon.conversion) %&gt;% filter(dbh_cm_bc &gt; 0)\n\n\nJoining with `by = join_by(taxon)`\n\n\nCode\nTR.LF1 &lt;- tree.averages %&gt;% filter(plot %in% \"1\")\nLF1.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF1\")\n\nTR.LF2 &lt;- tree.averages %&gt;% filter(plot %in% \"2\")\nLF2.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF2\")\n\nTR.LF3 &lt;- tree.averages %&gt;% filter(plot %in% \"3\")\nLF3.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF3\")\n\n# get the biomass for each site:\nTR.LF1$AGB_kg &lt;-\n  get_biomass(\n    dbh = TR.LF1$dbh_cm_bc ,\n    genus = TR.LF1$GENUS,\n    species = TR.LF1$SPECIES,\n    coords = c(LF1.ll$lon, LF1.ll$lat))\n\n\nTR.LF2$AGB_kg &lt;-\n  get_biomass(\n    dbh = TR.LF2$dbh_cm_bc,\n    genus = TR.LF2$GENUS,\n    species = TR.LF2$SPECIES,\n    coords = c(LF2.ll$lon, LF2.ll$lat))\n\nTR.LF3$AGB_kg &lt;-\n  get_biomass(\n    dbh = TR.LF3$dbh_cm_bc,\n    genus = TR.LF3$GENUS,\n    species = TR.LF3$SPECIES,\n    coords = c(LF3.ll$lon, LF3.ll$lat))\n\nTR.AGB &lt;- rbind(TR.LF1, TR.LF2, TR.LF3)\n\n\nggplot()+\n  geom_line(data = TR.AGB, aes(x = cal.year, y = AGB_kg, group = id, color = COMMON_NAME))+ylab(\"Tree Aboveground Biomass (kg)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\nFor the tree ring sample, a double-nested plot sampling design was deployed at harvard forest, where the smaller diameter trees (&lt;20cm) were sampled in the inner plot and large trees were sampled in the inner plot (&gt;=20cm). This means that each cored tree represents a different sub-sample of the population. We use unit conversions to convert tree biomass units from kg/plot to Mg/ha\n\n\nCode\n # we need to adjust the biomass units from kg/plot to Mg/ha\n    inner_factor = (1 / (pi*13^2)) * (1/0.0001) * (1/1000)\n    outer_factor = (1 / (pi*20^2)) * (1/0.0001) * (1/1000)\n    \n    \n   TR.AGB &lt;-  TR.AGB %&gt;% mutate(tph_corr = ifelse(dbh &gt;= 20, outer_factor, inner_factor)) #%&gt;% mutate(AGB_Mg_ha= AGB_kg*TPA_factor)\n   \n   saveRDS(TR.AGB, \"data/TR_AGB_ests_allodb.rds\")\n\n\nLet’s calculate the total taxon AGB over time & Aboveground biomass increment\n\n\nCode\nTAXA.AGB &lt;- TR.AGB %&gt;% group_by(COMMON_NAME, GENUS, SPECIES, cal.year, plot) %&gt;% \n  summarise(AGB_Mg_ha_taxa = sum(AGB_kg*tph_corr)) %&gt;% \n  filter(cal.year &lt;= 2010) %&gt;% \n  ungroup() %&gt;% \n  group_by(COMMON_NAME, GENUS, SPECIES, plot) %&gt;%\n  arrange(cal.year) %&gt;% \n  mutate(AGBI.taxa = AGB_Mg_ha_taxa - lag(AGB_Mg_ha_taxa)) \n\n\n`summarise()` has grouped output by 'COMMON_NAME', 'GENUS', 'SPECIES',\n'cal.year'. You can override using the `.groups` argument.\n\n\nCode\nggplot()+\n  geom_line(data = TAXA.AGB, aes(x = cal.year, y = AGB_Mg_ha_taxa, color = COMMON_NAME), size = 2)+ylab(\"Taxa Aboveground Biomass (Mg/ha)\")+xlab(\"Year\")+facet_wrap(~plot)\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\nCode\nggplot()+\n  geom_line(data = TAXA.AGB, aes(x = cal.year, y = AGBI.taxa, color = COMMON_NAME), size = 2)+ylab(\"Taxa Aboveground Biomass Increment (Mg/ha)\")+xlab(\"Year\")+facet_wrap(~plot)\n\n\nWarning: Removed 9 rows containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\nThe simplest way of estimating Carbon from tree-level biomass is to assume that the “carbon fraction,” that is the fraction of the tree’s weight that is made up of Carbon, is 50%, so multiplying your biomass value by 0.5 will give you a mass of Carbon per unit area.\nOther carbon fractions are available, for example for live trees vs. dead trees, and for different forest types/species, but for simplicity we will use 0.5 here.\n\n\nCode\nTAXA.C &lt;- TR.AGB %&gt;% group_by(COMMON_NAME, GENUS, SPECIES, cal.year, plot) %&gt;% \n  summarise(Carbon_Mg_ha_taxa = sum(AGB_kg*tph_corr*0.5)) #%&gt;% \n\n\n`summarise()` has grouped output by 'COMMON_NAME', 'GENUS', 'SPECIES',\n'cal.year'. You can override using the `.groups` argument.\n\n\nCode\n  # ungroup()%&gt;%\n  # # average across sites\n  # summarise(Carbon_Mg_ha_taxa_avg = mean(Carbon_Mg_ha_taxa))%&gt;% filter(cal.year &lt;= 2010)\n\nggplot()+\n  geom_line(data = TAXA.C, aes(x = cal.year, y = Carbon_Mg_ha_taxa, color = COMMON_NAME), line_width = 2)+ylab(\"Taxa Aboveground Carbon (Mg C/ha)\")+xlab(\"Year\")+facet_wrap(~plot)\n\n\nWarning in geom_line(data = TAXA.C, aes(x = cal.year, y = Carbon_Mg_ha_taxa, :\nIgnoring unknown parameters: `line_width`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nCensus.totals &lt;- Census.AGB.sums %&gt;% left_join(.,taxon.conversion) %&gt;% \n  group_by(COMMON_NAME, INV.YEAR) %&gt;% \n  summarise(AGB_Mg_ha_Site = mean(AGB_Mg_ha_taxon))\n\n\nJoining with `by = join_by(taxon, `Scientific Name`)`\n`summarise()` has grouped output by 'COMMON_NAME'. You can override using the\n`.groups` argument.\n\n\nCode\nTR.totals &lt;- TAXA.AGB %&gt;% \n  group_by(COMMON_NAME, cal.year) %&gt;% \n  summarise(AGB_Mg_ha_Site = mean(AGB_Mg_ha_taxa))\n\n\n`summarise()` has grouped output by 'COMMON_NAME'. You can override using the\n`.groups` argument.\n\n\nCode\nggplot()+\n  geom_line(data = TR.totals , aes(x = cal.year, y = AGB_Mg_ha_Site, color = \"Tree Ring\"), size = 2)+\n  geom_point(data = Census.totals, aes(x = INV.YEAR, y = AGB_Mg_ha_Site, color = \"Census\"), size= 2) + ylab(\"Taxa Aboveground Biomass (Mg/ha)\")+xlab(\"Year\")+facet_wrap(~COMMON_NAME, scales = \"free_y\")+\n  scale_color_manual(values = c(\"Tree Ring\" = \"brown\", \n                                \"Census\" = \"forestgreen\"), \n                     name = \"Data Source\")",
    "crumbs": [
      "Home",
      "Module 3: Estimating Biomass From Tree Ring Data"
    ]
  },
  {
    "objectID": "Module_3_Biomass_estimation.html#estimating-forest-biomass-for-trees-at-the-time-of-census",
    "href": "Module_3_Biomass_estimation.html#estimating-forest-biomass-for-trees-at-the-time-of-census",
    "title": "Module 3: Estimating Biomass From Tree Ring Data",
    "section": "",
    "text": "This package is available on github, and we highlight some additional resources here:\n\nCitation: Gonzalez-Akre, E.,  Piponiot, C.,  Lepore, M.,  Herrmann, V.,  Lutz, J. A.,  Baltzer, J. L.,  Dick, C. W.,  Gilbert, G. S., He, F.,  Heym, M.,  Huerta, A. I.,  Jansen, P. A.,  Johnson, D. J.,  Knapp, N.,  Král, K.,  Lin, D.,  Malhi, Y.,  McMahon, S. M.,  Myers, J. A., …  Anderson-Teixeira, K. J. (2022).  allodb: An R package for biomass estimation at globally distributed extratropical forest plots. Methods in Ecology and Evolution,  13,  330–338. https://doi.org/10.1111/2041-210X.13756\nGithub repository: https://github.com/ropensci/allodb/tree/master\nTutorial at Ropensci: https://docs.ropensci.org/allodb/\n\n\n\nCode\ndevtools::install_github(\"ropensci/allodb\",upgrade = \"never\")\nlibrary(allodb)\nlibrary(tidyverse)\nlibrary(dplR)\nlibrary(gt)\nlibrary(reshape2)\n\nHARV &lt;- readRDS(\"data/tree_data_HARVARD_STAN_v3.1_102020.RDS\")\n\n\ntaxon.conversion &lt;- readRDS(\"data/taxon_conversion.RDS\")\n\nTree.ring &lt;- HARV$Xobs %&gt;% left_join(., HARV$Tr)\n\n# get the calendar years\nyear.df &lt;- data.frame(year = max(Tree.ring$year):1, \n                      cal.year = 2012:(2013 - max(Tree.ring$year)))\n\nTree.ring &lt;- Tree.ring %&gt;% left_join(., year.df)\n\nyear.df &lt;- data.frame(year = max(Tree.ring$year):1, \n                      cal.year = 2012:(2013 - max(Tree.ring$year)))\n# set up the lat-long information:\nHARV.ll &lt;- data.frame(site = c(\"LF1\", \"LF2\", \"LF3\"), \n                      lat = c(42.53065, 42.53128, 42.53008), \n                      lon = c(-72.18346, -72.18271, -72.18246))\n\nCensus &lt;- HARV$Dobs %&gt;% left_join(., year.df) %&gt;% \n  rename(\"taxon\" = \"species\")%&gt;%\n  left_join(., taxon.conversion) %&gt;%# combine with taxon-infomation\n  left_join(., HARV.ll) # combine with lat-long information\n\nCensus &lt;- Census %&gt;% \n  mutate(INV.YEAR = ifelse(cal.year &gt;= 1985 & cal.year &lt;= 1991, 1990, cal.year))\n\n\nHere, we will focus on species from Harvard Forest, so lets see which species we have in our census data. This information is stored in the taxon column in the Census object:\n\n\nCode\n# lets visualize the number of trees sampled at Harvard Forest each census year:\nCensus %&gt;% group_by(taxon, `Scientific Name`, COMMON_NAME, INV.YEAR) %&gt;%\n  summarise(n.trees = n()) %&gt;% \n  group_by(taxon, `Scientific Name`, COMMON_NAME) %&gt;% \n  spread(INV.YEAR, n.trees, fill = 0) %&gt;%\n  ungroup() %&gt;% gt()\n\n\n\n\n\n\n\n\ntaxon\nScientific Name\nCOMMON_NAME\n1960\n1967\n1973\n1990\n1999\n2009\n\n\n\n\nACRU\nAcer rubrum\nred maple\n41\n211\n188\n141\n111\n90\n\n\nBEAL\nBetula alleghaniensis\nyellow birch\n8\n17\n18\n16\n24\n29\n\n\nBELE\nBetula lenta\nsweet birch\n2\n5\n5\n7\n10\n16\n\n\nFAGR\nFagus grandifolia\nAmerican beech\n2\n4\n4\n12\n16\n26\n\n\nHAVI\nHamamelis virginiana\nAmerican witchhazel\n2\n5\n5\n9\n10\n25\n\n\nPIST\nPinus strobus\neastern white pine\n4\n29\n24\n6\n8\n8\n\n\nQURU\nQuercus rubra\nnorthern red oak\n27\n129\n114\n79\n73\n67\n\n\nQUVE\nQuercus velutina\nblack oak\n1\n7\n6\n4\n3\n3\n\n\nTSCA\nTsuga canadensis\neastern hemlock\n3\n4\n7\n8\n13\n25\n\n\n\n\n\n\n\nCode\n# we can also plot this up visually:\n\nggplot(data = Census)+\ngeom_bar(aes(x = as.character(INV.YEAR), fill = `Scientific Name`), position = \"dodge\")+theme_bw()+\nylab(\"Number of Trees Observed\")+\nxlab(\"Inventory Year\")+facet_wrap(~site, ncol = 1)\n\n\n\n\n\n\n\n\n\nBased on this table and figure, which species do you think will have the largest aboveground biomass?\n\n\n\nThis function requires the following arguments and provides and output of Aboveground biomass in kilograms (kg):\n\ndbh: diameter at breast height (cm), numeric\ngenus: genus of the tree, character\nspecies: the species name of the tree, character, can be NULL if only genus is known\ncoords: a vector (longitude, latitude) of the plot location, or a matrix with 2 columns if trees have individual locations\n\n\n\nCode\nrequire(allodb)\n\n# lets get the biomass for the first tree in the Census data (a 36.83 cm Northern Red Oak (Quercus rubra):\n\nCensus.1 &lt;- Census[1,] # first tree\n\nCensus.1$AGB.1 &lt;-\n  get_biomass(\n    dbh = Census.1$dbh ,\n    genus = Census.1$GENUS,\n    species = Census.1$SPECIES,\n    coords = c(Census.1$lon, Census.1$lat)\n  )\n\nCensus.1$AGB\n\n\n[1] 979.5547\n\n\nNow lets apply this function to the whole dataset\n\n\nCode\nll &lt;- matrix(c(Census$lon, Census$lat), nrow = length(Census$lon), ncol = 2, byrow = FALSE, dimnames = NULL)\n\n# here we split up the census by sites \nCensus.LF1 &lt;- Census %&gt;% filter(site %in% \"LF1\")\nLF1.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF1\")\n\nCensus.LF2 &lt;- Census %&gt;% filter(site %in% \"LF2\")\nLF2.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF2\")\n\nCensus.LF3 &lt;- Census %&gt;% filter(site %in% \"LF3\")\nLF3.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF3\")\n\n# get the biomass for each site:\nCensus.LF1$AGB_kg &lt;-\n  get_biomass(\n    dbh = Census.LF1$dbh ,\n    genus = Census.LF1$GENUS,\n    species = Census.LF1$SPECIES,\n    coords = c(LF1.ll$lon, LF1.ll$lat))\n\n\nCensus.LF2$AGB_kg &lt;-\n  get_biomass(\n    dbh = Census.LF2$dbh ,\n    genus = Census.LF2$GENUS,\n    species = Census.LF2$SPECIES,\n    coords = c(LF2.ll$lon, LF2.ll$lat))\n\nCensus.LF3$AGB_kg &lt;-\n  get_biomass(\n    dbh = Census.LF3$dbh ,\n    genus = Census.LF3$GENUS,\n    species = Census.LF3$SPECIES,\n    coords = c(LF3.ll$lon, LF3.ll$lat))\n\nplot_radius = 20\n\n\nCensus.AGB &lt;- rbind(Census.LF1, Census.LF2, Census.LF3) %&gt;% \n  mutate(tph_corr = (1/(pi*plot_radius^2)) * (1/0.0001) * (1/1000)) #%&gt;%  # get tree per hectare correction factor to scale tree biomass up\n  #mutate(AGB_Mg_ha = AGB_kg*) # convert the tree level AGB to MG/ha)\n\n\n\nggplot(data = Census.AGB)+\n  geom_point(aes(x = INV.YEAR, y = AGB_kg, group = ID, color = `Scientific Name`))+\n  geom_line(aes(x = INV.YEAR, y = AGB_kg, group = ID, color = `Scientific Name`))+\n  facet_wrap(~site)+theme_bw()+ylab(\"Tree Aboveground Biomass (kg)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\n\nWhich species are increasing the most over time? Is this what you expected based on the number of trees tallied? Here, we have added lines to visualize the trajectory of taxon AGB over time, but we don’t have estimates of variability in annual AGB increment over time.\n\n\nCode\n# ggplot(data = Census.AGB)+\n#   geom_point(aes(x = INV.YEAR, y =AGB_Mg_ha, group = ID, color = `Scientific Name`))+\n#   geom_line(aes(x = INV.YEAR, y = AGB_Mg_ha, group = ID, color = `Scientific Name`))+\n#   facet_wrap(~site)+theme_bw()+ylab(\"Tree Aboveground Biomass (Mg/ha)\")+xlab(\"Year\")\n\nCensus.AGB.sums &lt;- Census.AGB %&gt;% group_by(taxon, `Scientific Name`, site, INV.YEAR) %&gt;% \n  summarise(AGB_Mg_ha_taxon = sum(AGB_kg*tph_corr, na.rm =TRUE))\n\nggplot(data = Census.AGB.sums)+\n  geom_point(aes(x = INV.YEAR, y = AGB_Mg_ha_taxon, color = `Scientific Name`))+\n  geom_line(aes(x = INV.YEAR, y = AGB_Mg_ha_taxon, color = `Scientific Name`))+\n  facet_wrap(~site)+theme_bw()+ylab(\"Taxon Aboveground Biomass (Mg/ha)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\n\nForest demographic processes affecting AGB:\n\nRecruitment of new small trees into the plot\nMortality of trees (or conversely, survival)\nGrowth of existing trees in the plot\n\nCensus data provide an estimate of these processes over the remeasurement period.\nRecruitment makes up a small amount of AGB at these plots:\n\n\n  site     ID taxon variable    value recruit.code   Recruitment\n1  LF1 LF1001  TSCA     1960       NA            0 Existing Tree\n2  LF1 LF1001  TSCA     1967       NA            0 Existing Tree\n3  LF1 LF1001  TSCA     1973       NA            0 Existing Tree\n4  LF1 LF1001  TSCA     1990 19.36831            1   New Recruit\n5  LF1 LF1001  TSCA     1999 45.02890            0 Existing Tree\n6  LF1 LF1001  TSCA     2009 99.23069            0 Existing Tree\n\n\n\n\n\n\n\n\n\nThere are some mortality events that remove AGB\n\n\n\n\n\n\n\n\n\nTree and taxon average annual growth and average annual aboveground biomass increment (AGBI) appear to vary across remeasurement periods:\n\n\nCode\n# Growth\nAverage.Growth.census &lt;- mortality.code.census %&gt;% \n  group_by(site, ID) %&gt;%\n  arrange(cal.year) %&gt;% \n  mutate(REMPER = cal.year - lag(cal.year),\n         prevDBH = lag(dbh), \n         prevAGB = lag(AGB_kg)) %&gt;% \n  # if the tree died in the remeasurement period, assume it died halfway through \n  mutate(REMPER.mort.corrected = ifelse(mort.code == 1, REMPER/2, REMPER)) %&gt;%\n  ungroup() %&gt;%\n  mutate(tree.AGBI = (AGB_kg - prevAGB)/REMPER.mort.corrected, \n         tree.growth = (dbh - prevDBH)/REMPER.mort.corrected) \n\n\nggplot(data = Average.Growth.census) + \n  geom_point(aes(x = INV.YEAR, y = tree.AGBI, color = taxon, group = ID))+\n  geom_line(aes(x = INV.YEAR, y = tree.AGBI, color = taxon, group = ID))+ facet_wrap(~site)+ylab(\"Tree Average Aboveground Biomass Increment (kg/year)\")\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = Average.Growth.census) + \n  geom_point(aes(x = INV.YEAR, y = tree.growth, color = taxon, group = ID))+\n  geom_line(aes(x = INV.YEAR, y = tree.growth, color = taxon, group = ID))+ facet_wrap(~site)+ylab(\"Tree Average Growth Increment (cm/year)\")+xlab(\"Inventory Year\")\n\n\n\n\n\n\n\n\n\nCode\nsite.avgs &lt;- Average.Growth.census %&gt;% group_by(site, taxon, INV.YEAR)%&gt;%\n  summarise(taxon.AGBI.avg = mean(tree.AGBI, na.rm =TRUE), \n            taxon.DI.avg = mean(tree.AGBI, na.rm =TRUE))\nggplot(data = site.avgs) + \n  geom_point(aes(x = INV.YEAR, y = taxon.DI.avg, color = taxon))+\n  geom_line(aes(x = INV.YEAR, y = taxon.DI.avg, color = taxon))+ facet_wrap(~site)+ylab(\"Taxon Average Growth Increment (cm/year)\")+xlab(\"Inventory Year\")\n\n\n\n\n\n\n\n\n\nCode\nggplot(data = site.avgs) + \n  geom_point(aes(x = INV.YEAR, y = taxon.AGBI.avg, color = taxon))+\n  geom_line(aes(x = INV.YEAR, y = taxon.AGBI.avg, color = taxon))+ facet_wrap(~site)+ylab(\"Taxon Average AGBI (kgyear)\")+xlab(\"Inventory Year\")\n\n\n\n\n\n\n\n\n\nHowever, some remeasurement periods are quite long, and we miss inter-annual variation that could lead to differences in estimates of annual AGBI. Tree-ring data can help us fill in these gaps in our understanding of how AGB varies over time, since they are a direct measurement of annual growth.",
    "crumbs": [
      "Home",
      "Module 3: Estimating Biomass From Tree Ring Data"
    ]
  },
  {
    "objectID": "Module_3_Biomass_estimation.html#step-2-use-tree-ring-data-to-back-calculate-tree-diameter-at-harvard-forest",
    "href": "Module_3_Biomass_estimation.html#step-2-use-tree-ring-data-to-back-calculate-tree-diameter-at-harvard-forest",
    "title": "Module 3: Estimating Biomass From Tree Ring Data",
    "section": "",
    "text": "In order to use tree ring data to estimate tree AGB, we first need to convert measurements of annual tree growth into estimates of tree diameter.\nThere are many different ways to convert tree ring radial increments to an estimate of circumference (i.e. diameter) and to an estimate of area (i.e. basal area). The dplR package from opendendro has some functions to calculate basal area increment–check out bai.in, bai.out, and bakker.\nFor simplicity here, we will we assume that each tree grows symmetrically and in a circle. So we convert tree ring growth data for each core from radial increment to a diameter increment by multiplying by 2. Because we have a diameter measurement from a recent census, we can back-calculate the diameter by subtracting the following year’s increment. To calculate the Diameter for core () in the year just before the census diameter was taken year (), we subtract the diameter increment growth () from the Census measured Diameter \n\n\nRead in the rwl files for red maple at Harvard Forest (using read.tucson function in dplR) and link them up to the census dataset.\n\n\nCode\nlibrary(dplR)\n# read in the rwl files using the helpful dplR functions:\nall.HF.rwl &lt;- list.files(\"data/rwl/\", pattern = \".rwl\", full.names = T)\n\n\nread.rwl.reformat &lt;- function(SPCD.rwl){\n        inc.rwl &lt;- read.tucson(SPCD.rwl)\n        # here, I reformat the data as a dataframe, get a tree id (id), and keep a core.id.\n        # the core.id is a separate core that denotes what direction on the tree the sample was taken from\n        inc.rwl.df &lt;- data.frame(inc.rwl) %&gt;% mutate(cal.year = row.names(inc.rwl)) %&gt;%\n          reshape2::melt(., id.vars = \"cal.year\") %&gt;% \n          rename(\"core.id\" = \"variable\", \n                 \"incr\" = \"value\") %&gt;%\n          mutate(id = substr(core.id, 1, 6)) %&gt;% \n          filter(!is.na(incr))%&gt;%\n          mutate(cal.year = as.numeric(cal.year))\n        \n        return(inc.rwl.df)\n\n}\n\nall.HF.increment &lt;- do.call(rbind, lapply(all.HF.rwl, read.rwl.reformat))\n# get the diameter measurements for the cored trees:\nCored.Diam &lt;- HARV$Tr %&gt;% left_join(., year.df) %&gt;%\n  left_join(., all.HF.increment ) %&gt;% filter(!is.na(core.id)) %&gt;% select(-incr)%&gt;%\n  rename(\"cored.year\"=\"year\", \n         \"cored.cal.year\"= \"cal.year\")\n\ninc.diam &lt;- all.HF.increment  %&gt;% left_join(., Cored.Diam)\n\n# example of back-calculating diameters for all the red maple cores\ncore.all &lt;- inc.diam %&gt;% \n  \n  # filter so we only have increments from the last census diameter measurement or earlier (for now)\n  filter(cal.year &lt;= cored.cal.year) %&gt;% \n  \n  # get the cumulative diameter increment, or how much the tree has grown from the outside in since a given year:\n  # The increments are in mm, so convert to cm by dividing by 10\n  # assume the tree is a perfect circle so multiply by 2 to get the diameter increment\n\n  #filter(id %in% \"LF1035\") %&gt;% \n  group_by(core.id) %&gt;% \n  arrange(desc(cal.year)) %&gt;% \n  \n  # calculate the cumulative sum of diameter increments, from the cored diameter to the earliest:\n  mutate(cum.diainc = cumsum((incr/10)*2), \n         dia.inc = (incr/10)*2) %&gt;% \n  # simplify this dataset for use:\n  select(cal.year, cored.cal.year, core.id, incr, id, dbh, cum.diainc, dia.inc, plot) %&gt;%\n  ungroup()%&gt;%\n  \n  # grouping by the core id after arranging by calendar year is important!!\n  group_by(core.id) %&gt;%\n  # if the year is the year the cored tree diameter was measured, use that as the dbh\n  mutate(dbh_cm_bc = ifelse(cal.year == cored.cal.year, dbh, \n  # if the year is before the tree was cored, use lag to subtract the cumulative increment\n  # lag gives use the previous value (gives the cumulative diameter increment from year == 2012 for cal.year == 2011)\n                            ifelse(cal.year &lt; cored.cal.year, dbh - lag(cum.diainc), NA)))\n  \n  # to convince yourself that this is working right, check that the estimated increments == the tree diameter increment:\n  # core.all %&gt;% mutate(check.dia.inc = dbh_cm_bc - lead(dbh_cm_bc)) %&gt;% \n  #   filter(!round(dia.inc, 3) == round(check.dia.inc, 3) )\n\n\n\n\nCode\neast.core &lt;- core.all %&gt;% filter(core.id %in% \"LF1005e\")\n ggplot()+geom_line(data = east.core, aes(x = cal.year, y = dbh_cm_bc, color = core.id))+\n   geom_point(data = east.core %&gt;% filter(cal.year == cored.cal.year), aes(x = cal.year, y = dbh))+ylab(\"Tree diameter (cm)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\n\nUsing our simple method get a back-calculated tree diameter estimate based on each core. When using tree-ring data to estimate trends in tree size (or Basal Area, Aboveground Biomass, etc), the variation in tree ring widths from different cores in the same tree and year represents observation uncertainty. Here, a single red maple tree (LF1005) has three cores, with variability in tree ring increment and the back-calculated tree size.\n\n\nCode\nLF2012 &lt;- core.all %&gt;% filter(id %in% \"LF1005\")\n\n DBH.bc.p &lt;- ggplot()+geom_line(data = LF2012, aes(x = cal.year, y = dbh_cm_bc, color = core.id))+\n   geom_point(data = LF2012 %&gt;% filter(cal.year == cored.cal.year), aes(x = cal.year, y = dbh))+ylab(\"Tree diameter (cm)\")+xlab(\"Year\")\n \n inc.p &lt;-  ggplot()+geom_line(data = LF2012, aes(x = cal.year, y = dia.inc, color = core.id))+\n   ylab(\"Tree Diameter Increment (cm)\")+xlab(\"Year\")\n \n cowplot::plot_grid(inc.p, DBH.bc.p, ncol = 1)\n\n\n\n\n\n\n\n\n\nWe note that the approach in this module has some issues, including the possibility of estimating negative tree diameters near the beginning of the time series, ignoring bark thickness, and assuming perfectly circular tree trunks.\nLater in our tutorial, we will demonstrate how developing a “data model” can allow us to estimate uncertainty due to information from different cores and to include this uncertainty in our estimates of tree diameter and aboveground biomass. For this module, we will average the diameter increments for each core before back-calculating the diameters to demonstrate how to estimate biomass over time.\n\n\n\n\n\nCode\ntree.averages &lt;- inc.diam %&gt;% \n  group_by(id, cal.year, dbh, cored.cal.year, taxon, plot) %&gt;%\n  summarise(incr.avg = mean(incr, na.rm = TRUE)) %&gt;% \n  \n  # filter so we only have increments from the last census diameter measurement or earlier (for now)\n  filter(cal.year &lt;= cored.cal.year) %&gt;% \n  \n  # get the cumulative diameter increment, or how much the tree has grown from the outside in since a given year:\n  # The increments are in mm, so convert to cm by dividing by 10\n  # assume the tree is a perfect circle so multiply by 2 to get the diameter increment\n  group_by(id) %&gt;% \n  arrange(desc(cal.year)) %&gt;% \n  \n  # calculate the cumulative sum of diameter increments, from the cored diameter to the earliest:\n  mutate(cum.diainc = cumsum((incr.avg/10)*2), \n         dia.inc = (incr.avg/10)*2) %&gt;% \n  # simplify this dataset for use:\n  select(cal.year, cored.cal.year, incr.avg, id, dbh, cum.diainc, dia.inc, plot, taxon) %&gt;%\n  ungroup()%&gt;%\n  \n  # grouping by the core id after arranging by calendar year is important!!\n  group_by(id) %&gt;%\n  # if the year is the year the cored tree diameter was measured, use that as the dbh\n  mutate(dbh_cm_bc = ifelse(cal.year == cored.cal.year, dbh, \n  # if the year is before the tree was cored, use lag to subtract the cumulative increment\n  # lag gives use the previous value (gives the cumulative diameter increment from year == 2012 for cal.year == 2011)\n                            ifelse(cal.year &lt; cored.cal.year, dbh - lag(cum.diainc), NA)))\n\n\n`summarise()` has grouped output by 'id', 'cal.year', 'dbh', 'cored.cal.year',\n'taxon'. You can override using the `.groups` argument.\n\n\nCode\n ggplot()+geom_line(data = tree.averages, aes(x = cal.year, y = dbh_cm_bc, group = id, color = taxon))+\n   geom_point(data = tree.averages %&gt;% filter(cal.year == cored.cal.year), aes(x = cal.year, y = dbh))+ylab(\"Tree diameter (cm)\")+xlab(\"Year\")",
    "crumbs": [
      "Home",
      "Module 3: Estimating Biomass From Tree Ring Data"
    ]
  },
  {
    "objectID": "Module_3_Biomass_estimation.html#converting-forest-biomass-to-carbon-using-carbon-fractions",
    "href": "Module_3_Biomass_estimation.html#converting-forest-biomass-to-carbon-using-carbon-fractions",
    "title": "Module 3: Estimating Biomass From Tree Ring Data",
    "section": "",
    "text": "We convert back-calculated tree diameters to aboveground biomass, again using the allometric equations in the allodb package.\n\n\nCode\ntree.averages &lt;- tree.averages %&gt;% left_join(.,taxon.conversion) %&gt;% filter(dbh_cm_bc &gt; 0)\n\n\nJoining with `by = join_by(taxon)`\n\n\nCode\nTR.LF1 &lt;- tree.averages %&gt;% filter(plot %in% \"1\")\nLF1.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF1\")\n\nTR.LF2 &lt;- tree.averages %&gt;% filter(plot %in% \"2\")\nLF2.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF2\")\n\nTR.LF3 &lt;- tree.averages %&gt;% filter(plot %in% \"3\")\nLF3.ll &lt;- HARV.ll %&gt;% filter(site %in% \"LF3\")\n\n# get the biomass for each site:\nTR.LF1$AGB_kg &lt;-\n  get_biomass(\n    dbh = TR.LF1$dbh_cm_bc ,\n    genus = TR.LF1$GENUS,\n    species = TR.LF1$SPECIES,\n    coords = c(LF1.ll$lon, LF1.ll$lat))\n\n\nTR.LF2$AGB_kg &lt;-\n  get_biomass(\n    dbh = TR.LF2$dbh_cm_bc,\n    genus = TR.LF2$GENUS,\n    species = TR.LF2$SPECIES,\n    coords = c(LF2.ll$lon, LF2.ll$lat))\n\nTR.LF3$AGB_kg &lt;-\n  get_biomass(\n    dbh = TR.LF3$dbh_cm_bc,\n    genus = TR.LF3$GENUS,\n    species = TR.LF3$SPECIES,\n    coords = c(LF3.ll$lon, LF3.ll$lat))\n\nTR.AGB &lt;- rbind(TR.LF1, TR.LF2, TR.LF3)\n\n\nggplot()+\n  geom_line(data = TR.AGB, aes(x = cal.year, y = AGB_kg, group = id, color = COMMON_NAME))+ylab(\"Tree Aboveground Biomass (kg)\")+xlab(\"Year\")\n\n\n\n\n\n\n\n\n\n\n\nFor the tree ring sample, a double-nested plot sampling design was deployed at harvard forest, where the smaller diameter trees (&lt;20cm) were sampled in the inner plot and large trees were sampled in the inner plot (&gt;=20cm). This means that each cored tree represents a different sub-sample of the population. We use unit conversions to convert tree biomass units from kg/plot to Mg/ha\n\n\nCode\n # we need to adjust the biomass units from kg/plot to Mg/ha\n    inner_factor = (1 / (pi*13^2)) * (1/0.0001) * (1/1000)\n    outer_factor = (1 / (pi*20^2)) * (1/0.0001) * (1/1000)\n    \n    \n   TR.AGB &lt;-  TR.AGB %&gt;% mutate(tph_corr = ifelse(dbh &gt;= 20, outer_factor, inner_factor)) #%&gt;% mutate(AGB_Mg_ha= AGB_kg*TPA_factor)\n   \n   saveRDS(TR.AGB, \"data/TR_AGB_ests_allodb.rds\")\n\n\nLet’s calculate the total taxon AGB over time & Aboveground biomass increment\n\n\nCode\nTAXA.AGB &lt;- TR.AGB %&gt;% group_by(COMMON_NAME, GENUS, SPECIES, cal.year, plot) %&gt;% \n  summarise(AGB_Mg_ha_taxa = sum(AGB_kg*tph_corr)) %&gt;% \n  filter(cal.year &lt;= 2010) %&gt;% \n  ungroup() %&gt;% \n  group_by(COMMON_NAME, GENUS, SPECIES, plot) %&gt;%\n  arrange(cal.year) %&gt;% \n  mutate(AGBI.taxa = AGB_Mg_ha_taxa - lag(AGB_Mg_ha_taxa)) \n\n\n`summarise()` has grouped output by 'COMMON_NAME', 'GENUS', 'SPECIES',\n'cal.year'. You can override using the `.groups` argument.\n\n\nCode\nggplot()+\n  geom_line(data = TAXA.AGB, aes(x = cal.year, y = AGB_Mg_ha_taxa, color = COMMON_NAME), size = 2)+ylab(\"Taxa Aboveground Biomass (Mg/ha)\")+xlab(\"Year\")+facet_wrap(~plot)\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\nCode\nggplot()+\n  geom_line(data = TAXA.AGB, aes(x = cal.year, y = AGBI.taxa, color = COMMON_NAME), size = 2)+ylab(\"Taxa Aboveground Biomass Increment (Mg/ha)\")+xlab(\"Year\")+facet_wrap(~plot)\n\n\nWarning: Removed 9 rows containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\nThe simplest way of estimating Carbon from tree-level biomass is to assume that the “carbon fraction,” that is the fraction of the tree’s weight that is made up of Carbon, is 50%, so multiplying your biomass value by 0.5 will give you a mass of Carbon per unit area.\nOther carbon fractions are available, for example for live trees vs. dead trees, and for different forest types/species, but for simplicity we will use 0.5 here.\n\n\nCode\nTAXA.C &lt;- TR.AGB %&gt;% group_by(COMMON_NAME, GENUS, SPECIES, cal.year, plot) %&gt;% \n  summarise(Carbon_Mg_ha_taxa = sum(AGB_kg*tph_corr*0.5)) #%&gt;% \n\n\n`summarise()` has grouped output by 'COMMON_NAME', 'GENUS', 'SPECIES',\n'cal.year'. You can override using the `.groups` argument.\n\n\nCode\n  # ungroup()%&gt;%\n  # # average across sites\n  # summarise(Carbon_Mg_ha_taxa_avg = mean(Carbon_Mg_ha_taxa))%&gt;% filter(cal.year &lt;= 2010)\n\nggplot()+\n  geom_line(data = TAXA.C, aes(x = cal.year, y = Carbon_Mg_ha_taxa, color = COMMON_NAME), line_width = 2)+ylab(\"Taxa Aboveground Carbon (Mg C/ha)\")+xlab(\"Year\")+facet_wrap(~plot)\n\n\nWarning in geom_line(data = TAXA.C, aes(x = cal.year, y = Carbon_Mg_ha_taxa, :\nIgnoring unknown parameters: `line_width`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nCensus.totals &lt;- Census.AGB.sums %&gt;% left_join(.,taxon.conversion) %&gt;% \n  group_by(COMMON_NAME, INV.YEAR) %&gt;% \n  summarise(AGB_Mg_ha_Site = mean(AGB_Mg_ha_taxon))\n\n\nJoining with `by = join_by(taxon, `Scientific Name`)`\n`summarise()` has grouped output by 'COMMON_NAME'. You can override using the\n`.groups` argument.\n\n\nCode\nTR.totals &lt;- TAXA.AGB %&gt;% \n  group_by(COMMON_NAME, cal.year) %&gt;% \n  summarise(AGB_Mg_ha_Site = mean(AGB_Mg_ha_taxa))\n\n\n`summarise()` has grouped output by 'COMMON_NAME'. You can override using the\n`.groups` argument.\n\n\nCode\nggplot()+\n  geom_line(data = TR.totals , aes(x = cal.year, y = AGB_Mg_ha_Site, color = \"Tree Ring\"), size = 2)+\n  geom_point(data = Census.totals, aes(x = INV.YEAR, y = AGB_Mg_ha_Site, color = \"Census\"), size= 2) + ylab(\"Taxa Aboveground Biomass (Mg/ha)\")+xlab(\"Year\")+facet_wrap(~COMMON_NAME, scales = \"free_y\")+\n  scale_color_manual(values = c(\"Tree Ring\" = \"brown\", \n                                \"Census\" = \"forestgreen\"), \n                     name = \"Data Source\")",
    "crumbs": [
      "Home",
      "Module 3: Estimating Biomass From Tree Ring Data"
    ]
  }
]